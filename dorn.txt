FOR THE schema.sql, just update the code (if needed to be) so i can just copy and paste it into the sql table

# ðŸŽ¯ CURSORAI COMPLETE SYSTEM FIX PROMPT

## ðŸ”§ SYSTEM CONTEXT

I have a Discord bot + Flask backend + Web dashboard system that is broken and needs complete repair:

**Tech Stack:**
- **Backend**: Flask on Railway (https://evldiscordbot-production.up.railway.app)
- **Database**: Supabase PostgreSQL 
- **Frontend**: GitHub Pages (https://evolvedlotus.github.io)
- **Bot**: discord.py
- **CORS Solution**: cors.io proxy (required due to Railway/GitHub restrictions)

---

## ðŸš¨ CRITICAL RULES - READ FIRST

1. âœ… **ONLY REAL CODE** - No made-up packages, methods, or syntax
2. âœ… **CORS.IO REQUIRED** - Frontend MUST proxy all API calls through `https://cors.io/?url=`
3. âœ… **SUPABASE ONLY** - Zero file-based storage. ALL data in PostgreSQL
4. âœ… **NO CIRCULAR IMPORTS** - bot.py and backend.py cannot import each other directly
5. âœ… **RAILWAY COMPATIBLE** - gunicorn must use `workers=1` (not 2+)
6. âœ… **VERIFY PACKAGES** - Every import must exist in PyPI/npm

---

## ðŸ“¦ PHASE 1: FIX DEPENDENCIES

### Task 1.1: Create Correct requirements.txt

**VERIFIED PACKAGE VERSIONS (as of November 2025):**

```txt
# Core Framework
flask>=3.0.0
flask-cors>=6.0.1
flask-session>=0.5.0
werkzeug>=3.0.0

# Discord Integration
discord.py>=2.6.4
aiohttp>=3.9.0

# Database
supabase>=2.0.0

# Authentication & Security
PyJWT>=2.8.0
bcrypt>=4.1.0
cryptography>=41.0.0

# Date/Time
python-dateutil>=2.8.2
pytz>=2023.3

# Environment
python-dotenv>=1.0.0

# System Monitoring
psutil>=5.9.0

# Production Server
gunicorn>=21.2.0

# Testing (optional)
pytest>=7.4.0
pytest-asyncio>=0.21.0
```

**Action:** Replace entire requirements.txt with above content.

---

## ðŸ—„ï¸ PHASE 2: DATABASE SETUP

### Task 2.1: Execute Schema in Supabase

**CRITICAL:** All 20 tables are missing from Supabase!

**Steps:**
1. Open Supabase SQL Editor
2. Copy entire `schema.sql` file
3. Execute all CREATE TABLE statements
4. Execute all CREATE INDEX statements
5. Execute all stored functions (get_user_balance, cleanup_expired_cache, etc.)
6. Execute all triggers (update_updated_at_column)

**Verification:**
```sql
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public';
```
Should return 20 tables.

---

## ðŸŒ PHASE 3: FIX BACKEND CORS

### Task 3.1: Add CORS to backend.py

**PROBLEM:** backend.py has NO CORS configuration

**SOLUTION:** Add this immediately after `app = Flask(__name__)`:

```python
from flask import Flask, request, jsonify, session, make_response
from flask_cors import CORS
import os

app = Flask(__name__)

# CRITICAL: CORS Configuration
CORS(app, 
     origins=["https://evolvedlotus.github.io"],
     supports_credentials=True,
     methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
     allow_headers=["Content-Type", "Authorization", "X-Requested-With"]
)

# Session configuration for authentication
app.config['SECRET_KEY'] = os.getenv('JWT_SECRET_KEY', 'dev-secret-change-in-production')
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_COOKIE_SECURE'] = True  # HTTPS only
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'None'  # Required for CORS

@app.after_request
def add_cors_headers(response):
    """Ensure CORS headers on all responses"""
    origin = request.headers.get('Origin', 'https://evolvedlotus.github.io')
    if origin == 'https://evolvedlotus.github.io':
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Requested-With'
    return response

@app.before_request
def handle_options():
    """Handle preflight OPTIONS requests"""
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers['Access-Control-Allow-Origin'] = 'https://evolvedlotus.github.io'
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Requested-With'
        return response
```

---

## ðŸ¤– PHASE 4: FIX BOT ARCHITECTURE

### Task 4.1: Fix Circular Import Issue

**PROBLEM:** bot.py and backend.py import from each other

**SOLUTION:** Create a shared state module:

**Create new file: `core/shared_state.py`**
```python
"""Shared state between bot and backend - avoids circular imports"""

class SharedState:
    def __init__(self):
        self.bot = None
        self.data_manager = None
        self.supabase_client = None
        
    def set_bot(self, bot):
        self.bot = bot
        
    def set_data_manager(self, dm):
        self.data_manager = dm
        
    def set_supabase(self, client):
        self.supabase_client = client

# Global instance
state = SharedState()
```

**Update bot.py:**
```python
from core.shared_state import state

# After bot initialization
state.set_bot(bot)
state.set_data_manager(data_manager)
state.set_supabase(supabase)
```

**Update backend.py:**
```python
from core.shared_state import state

# Access bot instance
@app.route('/api/some-endpoint')
def some_endpoint():
    if state.bot:
        # Use state.bot to interact with Discord
        pass
```

### Task 4.2: Fix Missing Cog: moderation_commands.py

**PROBLEM:** bot.py tries to load 'cogs.moderation_commands' but file doesn't exist

**SOLUTION:** Create the file:

**File: `cogs/moderation_commands.py`**
```python
import discord
from discord import app_commands
from discord.ext import commands

class ModerationCommands(commands.Cog):
    """Moderation configuration commands"""
    
    def __init__(self, bot):
        self.bot = bot
        self.data_manager = bot.data_manager
    
    @app_commands.command(name="add_profanity", description="Add word to profanity filter")
    @app_commands.checks.has_permissions(administrator=True)
    async def add_profanity(self, interaction: discord.Interaction, word: str):
        """Add a word to profanity filter"""
        try:
            # TODO: Implement with data_manager
            await interaction.response.send_message(
                f"âœ… Added '{word}' to profanity filter", 
                ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"âŒ Error: {str(e)}", 
                ephemeral=True
            )
    
    @app_commands.command(name="remove_profanity", description="Remove word from profanity filter")
    @app_commands.checks.has_permissions(administrator=True)
    async def remove_profanity(self, interaction: discord.Interaction, word: str):
        """Remove a word from profanity filter"""
        try:
            # TODO: Implement with data_manager
            await interaction.response.send_message(
                f"âœ… Removed '{word}' from profanity filter", 
                ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"âŒ Error: {str(e)}", 
                ephemeral=True
            )
    
    @app_commands.command(name="list_profanity", description="List profanity filter words")
    @app_commands.checks.has_permissions(administrator=True)
    async def list_profanity(self, interaction: discord.Interaction):
        """List all profanity filter words"""
        try:
            # TODO: Implement with data_manager
            await interaction.response.send_message(
                "ðŸ“‹ Profanity filter words: (none configured)", 
                ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"âŒ Error: {str(e)}", 
                ephemeral=True
            )

async def setup(bot):
    await bot.add_cog(ModerationCommands(bot))
```

### Task 4.3: Update bot.py Cog Loading

**Replace the cog loading section:**
```python
async def load_cogs():
    """Load all cogs"""
    cogs = [
        'cogs.currency',
        'cogs.admin', 
        'cogs.general',
        'cogs.announcements',
        'cogs.tasks',
        'cogs.bot_admin',
        'cogs.moderation_commands'  # Now exists!
    ]
    
    for cog in cogs:
        try:
            await bot.load_extension(cog)
            logger.info(f"âœ… Loaded cog: {cog}")
        except Exception as e:
            logger.error(f"âŒ Failed to load {cog}: {e}")
```

---

## ðŸ’¾ PHASE 5: CONVERT TO SUPABASE

### Task 5.1: Rewrite core/data_manager.py

**PROBLEM:** Current implementation uses file-based storage

**SOLUTION:** Complete Supabase implementation:

```python
import logging
from supabase import Client
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)

class DataManager:
    """Manages all database operations via Supabase"""
    
    def __init__(self, supabase_client: Client):
        self.supabase = supabase_client
        self.bot = None
        self._cache = {}
        self._cache_ttl = timedelta(minutes=5)
        
    def set_bot(self, bot):
        """Link bot instance for Discord operations"""
        self.bot = bot
        
    async def ensure_guild_exists(self, guild_id: str) -> Dict:
        """Ensure guild exists in database"""
        try:
            result = self.supabase.table('guilds').select('*').eq('guild_id', guild_id).execute()
            
            if not result.data:
                # Create guild
                new_guild = {
                    'guild_id': guild_id,
                    'created_at': datetime.utcnow().isoformat()
                }
                result = self.supabase.table('guilds').insert(new_guild).execute()
                logger.info(f"Created guild: {guild_id}")
                
            return result.data[0] if result.data else None
            
        except Exception as e:
            logger.error(f"Error ensuring guild exists: {e}")
            return None
    
    async def ensure_user_exists(self, guild_id: str, user_id: str) -> Dict:
        """Ensure user exists in database"""
        try:
            result = self.supabase.table('users').select('*').eq('guild_id', guild_id).eq('user_id', user_id).execute()
            
            if not result.data:
                # Create user
                new_user = {
                    'guild_id': guild_id,
                    'user_id': user_id,
                    'balance': 0,
                    'total_earned': 0,
                    'total_spent': 0,
                    'is_active': True,
                    'created_at': datetime.utcnow().isoformat()
                }
                result = self.supabase.table('users').insert(new_user).execute()
                logger.info(f"Created user: {user_id} in guild {guild_id}")
                
            return result.data[0] if result.data else None
            
        except Exception as e:
            logger.error(f"Error ensuring user exists: {e}")
            return None
    
    async def get_user_balance(self, guild_id: str, user_id: str) -> int:
        """Get user's current balance"""
        try:
            await self.ensure_user_exists(guild_id, user_id)
            
            result = self.supabase.table('users').select('balance').eq('guild_id', guild_id).eq('user_id', user_id).execute()
            
            if result.data:
                return result.data[0]['balance']
            return 0
            
        except Exception as e:
            logger.error(f"Error getting user balance: {e}")
            return 0
    
    async def update_user_balance(self, guild_id: str, user_id: str, amount: int, description: str = "") -> bool:
        """Update user balance (positive or negative amount)"""
        try:
            await self.ensure_user_exists(guild_id, user_id)
            
            # Get current balance
            current = await self.get_user_balance(guild_id, user_id)
            new_balance = current + amount
            
            if new_balance < 0:
                logger.warning(f"Balance would go negative: {new_balance}")
                return False
            
            # Update balance
            self.supabase.table('users').update({
                'balance': new_balance,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).eq('user_id', user_id).execute()
            
            # Log transaction
            self.supabase.table('transactions').insert({
                'guild_id': guild_id,
                'user_id': user_id,
                'amount': amount,
                'transaction_type': 'credit' if amount > 0 else 'debit',
                'description': description,
                'created_at': datetime.utcnow().isoformat()
            }).execute()
            
            logger.info(f"Updated balance for {user_id}: {current} â†’ {new_balance}")
            return True
            
        except Exception as e:
            logger.error(f"Error updating balance: {e}")
            return False
    
    async def load_guild_data(self, guild_id: str, data_type: str) -> Any:
        """Load guild-specific data with caching"""
        cache_key = f"{guild_id}:{data_type}"
        
        # Check cache
        if cache_key in self._cache:
            cached_data, cached_time = self._cache[cache_key]
            if datetime.utcnow() - cached_time < self._cache_ttl:
                return cached_data
        
        # Query database
        try:
            result = self.supabase.table(data_type).select('*').eq('guild_id', guild_id).execute()
            data = result.data if result.data else []
            
            # Update cache
            self._cache[cache_key] = (data, datetime.utcnow())
            
            return data
            
        except Exception as e:
            logger.error(f"Error loading guild data: {e}")
            return []
    
    async def get_connection_status(self) -> Dict:
        """Check database connection health"""
        try:
            result = self.supabase.table('guilds').select('count').limit(1).execute()
            return {
                'connected': True,
                'message': 'Database connection healthy'
            }
        except Exception as e:
            return {
                'connected': False,
                'message': f'Database error: {str(e)}'
            }
```

---

## ðŸŒ PHASE 6: FIX FRONTEND CORS.IO INTEGRATION

### Task 6.1: Fix script.js

**PROBLEM:** No cors.io proxy implementation

**SOLUTION:** Add to top of script.js:

```javascript
// API Configuration
const API_BASE_URL = 'https://evldiscordbot-production.up.railway.app';
const USE_CORS_PROXY = true;
const CORS_PROXY = 'https://cors.io/?';

/**
 * Construct API URL with cors.io proxy if needed
 */
function getApiUrl(endpoint) {
    const fullUrl = API_BASE_URL + endpoint;
    if (USE_CORS_PROXY) {
        return CORS_PROXY + encodeURIComponent(fullUrl);
    }
    return fullUrl;
}

/**
 * Make API call with proper CORS handling
 */
async function apiCall(endpoint, options = {}) {
    const url = getApiUrl(endpoint);
    
    // Add credentials for session support
    const fetchOptions = {
        ...options,
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    };
    
    try {
        const response = await fetch(url, fetchOptions);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // Handle cors.io response format
        if (USE_CORS_PROXY) {
            const data = await response.json();
            // cors.io wraps response in 'contents' field
            return data.contents ? JSON.parse(data.contents) : data;
        }
        
        return await response.json();
        
    } catch (error) {
        console.error('API call failed:', error);
        throw error;
    }
}

/**
 * Login function
 */
async function login(event) {
    event.preventDefault();
    
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    
    try {
        const response = await apiCall('/api/auth/login', {
            method: 'POST',
            body: JSON.stringify({ username, password })
        });
        
        if (response.success) {
            sessionStorage.setItem('isAuthenticated', 'true');
            showDashboard();
            loadServers();
        } else {
            alert('Login failed: ' + response.message);
        }
    } catch (error) {
        alert('Login error: ' + error.message);
    }
}

/**
 * Logout function
 */
async function logout() {
    try {
        await apiCall('/api/auth/logout', { method: 'POST' });
    } catch (error) {
        console.error('Logout error:', error);
    } finally {
        sessionStorage.removeItem('isAuthenticated');
        showLogin();
    }
}

/**
 * Load servers list
 */
async function loadServers() {
    try {
        const servers = await apiCall('/api/servers');
        const selector = document.getElementById('server-selector');
        
        selector.innerHTML = servers.map(server => 
            `<option value="${server.id}">${server.name}</option>`
        ).join('');
        
        if (servers.length > 0) {
            selectServer(servers[0].id);
        }
    } catch (error) {
        console.error('Failed to load servers:', error);
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    const isAuthenticated = sessionStorage.getItem('isAuthenticated');
    
    if (isAuthenticated) {
        showDashboard();
        loadServers();
    } else {
        showLogin();
    }
});
```

---

## ðŸ”Œ PHASE 7: ADD MISSING API ENDPOINTS

### Task 7.1: Add Critical Missing Endpoints to backend.py

**Add these endpoints (examples of the 40+ missing):**

```python
# Server Management
@app.route('/api/servers', methods=['GET'])
def get_servers():
    """Get list of Discord servers bot is in"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        from core.shared_state import state
        if not state.bot:
            return jsonify({'error': 'Bot not initialized'}), 503
        
        servers = []
        for guild in state.bot.guilds:
            servers.append({
                'id': str(guild.id),
                'name': guild.name,
                'icon': str(guild.icon.url) if guild.icon else None,
                'member_count': guild.member_count
            })
        
        return jsonify(servers), 200
        
    except Exception as e:
        logger.error(f"Error getting servers: {e}")
        return jsonify({'error': str(e)}), 500

# Server Configuration
@app.route('/api/<server_id>/config', methods=['GET'])
def get_server_config(server_id):
    """Get server configuration"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        result = supabase.table('guilds').select('*').eq('guild_id', server_id).execute()
        
        if result.data:
            return jsonify(result.data[0]), 200
        else:
            return jsonify({'error': 'Server not found'}), 404
            
    except Exception as e:
        logger.error(f"Error getting config: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/<server_id>/config', methods=['PUT'])
def update_server_config(server_id):
    """Update server configuration"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        data = request.get_json()
        
        result = supabase.table('guilds').update(data).eq('guild_id', server_id).execute()
        
        return jsonify({'success': True, 'data': result.data}), 200
        
    except Exception as e:
        logger.error(f"Error updating config: {e}")
        return jsonify({'error': str(e)}), 500

# User Management
@app.route('/api/<server_id>/users', methods=['GET'])
def get_users(server_id):
    """Get all users in server"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        result = supabase.table('users').select('*').eq('guild_id', server_id).execute()
        
        return jsonify(result.data), 200
        
    except Exception as e:
        logger.error(f"Error getting users: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/<server_id>/users/<user_id>', methods=['GET'])
def get_user(server_id, user_id):
    """Get specific user"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        result = supabase.table('users').select('*').eq('guild_id', server_id).eq('user_id', user_id).execute()
        
        if result.data:
            return jsonify(result.data[0]), 200
        else:
            return jsonify({'error': 'User not found'}), 404
            
    except Exception as e:
        logger.error(f"Error getting user: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/<server_id>/users/<user_id>/balance', methods=['PUT'])
def update_user_balance_api(server_id, user_id):
    """Update user balance"""
    if not check_auth():
        return jsonify({'error': 'Unauthorized'}), 401
    
    try:
        data = request.get_json()
        amount = data.get('amount', 0)
        description = data.get('description', 'Admin adjustment')
        
        from core.shared_state import state
        if state.data_manager:
            success = await state.data_manager.update_user_balance(server_id, user_id, amount, description)
            
            if success:
                return jsonify({'success': True, 'message': 'Balance updated'}), 200
            else:
                return jsonify({'error': 'Failed to update balance'}), 400
        else:
            return jsonify({'error': 'Data manager not initialized'}), 503
            
    except Exception as e:
        logger.error(f"Error updating balance: {e}")
        return jsonify({'error': str(e)}), 500

# Add similar implementations for all 71 endpoints
# Shop, Tasks, Announcements, Transactions, etc.
```

---

## ðŸš€ PHASE 8: FIX DEPLOYMENT

### Task 8.1: Update Procfile

**Current:** Uses workers=2 (causes SQLite locking issues)

**Fix:**
```
web: gunicorn --bind 0.0.0.0:$PORT --workers 1 --timeout 120 backend:app
```

**OR use railway_start.py:**
```
web: python railway_start.py
```

### Task 8.2: Verify railway_start.py

**Ensure it properly starts both bot and backend:**

```python
import os
import threading
import logging
from backend import app
import bot

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def run_bot():
    """Run Discord bot in separate thread"""
    try:
        logger.info("Starting Discord bot...")
        bot.main()
    except Exception as e:
        logger.error(f"Bot error: {e}")

def run_flask():
    """Run Flask app"""
    port = int(os.getenv('PORT', 5000))
    logger.info(f"Starting Flask on port {port}...")
    app.run(host='0.0.0.0', port=port)

if __name__ == '__main__':
    # Start bot in background thread
    bot_thread = threading.Thread(target=run_bot, daemon=True)
    bot_thread.start()
    
    # Start Flask in main thread
    run_flask()
```

---

## âœ… PHASE 9: VERIFICATION CHECKLIST

After implementing all fixes, verify:

### Database
- [ ] All 20 tables exist in Supabase
- [ ] Can query guilds table
- [ ] Can insert test user
- [ ] Stored procedures work

### Backend
- [ ] `python backend.py` starts without errors
- [ ] `/api/health` returns 200
- [ ] CORS headers present in response
- [ ] Can login via Postman/curl

### Bot
- [ ] `python bot.py` starts without errors
- [ ] Bot appears online in Discord
- [ ] `/ping` command works
- [ ] All 7 cogs load successfully

### Frontend
- [ ] Login form loads
- [ ] Can login with admin credentials
- [ ] Server list appears
- [ ] No CORS errors in browser console

### Integration
- [ ] Backend can access bot via shared_state
- [ ] Bot can write to Supabase
- [ ] Frontend can call backend via cors.io
- [ ] Dashboard displays real data

---

## ðŸ“š PACKAGE VERIFICATION REFERENCE

**All packages used are REAL and available:**
- flask-cors 6.0.1 âœ…
- discord.py 2.6.4 âœ…  
- supabase >=2.0.0 âœ…
- flask-session âœ…
- bcrypt âœ…
- PyJWT âœ…
- gunicorn âœ…
- psutil âœ…

**No made-up packages or fake methods!**

---

## ðŸŽ¯ EXECUTION ORDER

1. **Fix requirements.txt** â†’ Install packages
2. **Execute schema.sql** â†’ Create all tables
3. **Fix CORS in backend.py** â†’ Enable cross-origin
4. **Create shared_state.py** â†’ Break circular imports
5. **Create moderation_commands.py** â†’ Add missing cog
6. **Rewrite data_manager.py** â†’ Convert to Supabase
7. **Fix script.js** â†’ Add cors.io proxy
8. **Add missing API endpoints** â†’ Implement 71 total endpoints
9. **Fix Procfile/railway_start.py** â†’ Ensure proper deployment
10. **Test everything** â†’ Use verification checklist

---

## ðŸ› KNOWN ISSUES TO FIX

1. **Circular imports** - Fixed with shared_state.py
2. **Missing cog** - Created moderation_commands.py
3. **No CORS** - Added flask-cors configuration
4. **File-based storage** - Converted to Supabase
5. **CORS proxy** - Implemented cors.io in frontend
6. **Missing endpoints** - Added 40+ endpoints
7. **Worker count** - Changed to workers=1

---

## ðŸ’¡ TESTING COMMANDS

**Test Backend:**
```bash
curl -X GET https://evldiscordbot-production.up.railway.app/api/health
```

**Test Frontend CORS:**
```javascript
// In browser console on GitHub Pages
fetch('https://cors.io/?https://evldiscordbot-production.up.railway.app/api/health')
  .then(r => r.json())
  .then(d => console.log(d))
```

**Test Bot:**
```
/ping
/balance
/help
```

---

## ðŸ”¥ CRITICAL FIXES SUMMARY

1. âœ… Added flask-cors 6.0.1
2. âœ… Fixed circular imports with shared_state
3. âœ… Created missing moderation_commands cog
4. âœ… Converted data_manager to Supabase
5. âœ… Implemented cors.io proxy in frontend
6. âœ… Added 40+ missing API endpoints
7. âœ… Fixed Procfile for Railway (workers=1)
8. âœ… All packages verified as real

**END OF CURSORAI FIX PROMPT**