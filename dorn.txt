Cursor AI Prompt: Complete Production Readiness Audit for Railway + Netlify Deployment
Objective
Perform a comprehensive, line-by-line audit of the entire codebase to identify and fix ALL potential deployment issues for Railway (backend) and Netlify (frontend) before they cause runtime failures.
Part 1: Flask Backend Audit (backend.py) - complete
1.1 Route Endpoint Collision Check
Search for: Every @app.route decorator in backend.py
Verify:

 Every route has explicit endpoint='unique_name' parameter
 No two endpoints share the same name
 Routes with same URL but different methods have different endpoint names

Command to run:
python# Create this verification script: check_endpoints.py
import re

with open('backend.py', 'r') as f:
    content = f.read()
    
routes = re.findall(r"@app\.route\([^)]+\)", content)
endpoints = re.findall(r"endpoint='([^']+)'", content)

print(f"Total routes: {len(routes)}")
print(f"Total endpoints: {len(endpoints)}")
print(f"Unique endpoints: {len(set(endpoints))}")

if len(endpoints) != len(set(endpoints)):
    print("❌ DUPLICATE ENDPOINTS FOUND:")
    from collections import Counter
    dupes = [e for e, count in Counter(endpoints).items() if count > 1]
    print(dupes)
else:
    print("✅ All endpoints are unique")

if len(routes) != len(endpoints):
    print(f"⚠️  WARNING: {len(routes) - len(endpoints)} routes missing explicit endpoints")
1.2 Decorator Function Preservation - complete
Search for: All custom decorator definitions
Pattern to find:
pythondef some_decorator(f):
    def wrapper(*args, **kwargs):
        # decorator logic
        return f(*args, **kwargs)
    return wrapper
Required fix:
pythonfrom functools import wraps

def some_decorator(f):
    @wraps(f)  # ✅ MUST BE HERE
    def wrapper(*args, **kwargs):
        # decorator logic
        return f(*args, **kwargs)
    return wrapper
Check these decorators:

 jwt_required()
 require_auth()
 Any custom @app.before_request handlers
 Any other function decorators

1.3 Environment Variable Validation - complete
File: backend.py, railway_start.py, bot.py
Required environment variables for Railway:
python# Add this validation block at the top of backend.py and bot.py
import os
import sys

REQUIRED_ENV_VARS = {
    'DISCORD_TOKEN': 'Discord bot token',
    'SUPABASE_URL': 'Supabase project URL',
    'SUPABASE_KEY': 'Supabase service role key',
    'JWT_SECRET_KEY': 'JWT secret for authentication',
    'PORT': 'Server port (Railway auto-assigns)',
}

missing = []
for var, description in REQUIRED_ENV_VARS.items():
    if not os.getenv(var):
        missing.append(f"{var} ({description})")

if missing:
    print("❌ MISSING REQUIRED ENVIRONMENT VARIABLES:")
    for m in missing:
        print(f"  - {m}")
    sys.exit(1)
Verify:

 All required env vars are defined
 No hardcoded secrets in code
 .env.railway exists with all variables
 railway.toml is properly configured

1.4 Port Configuration Check - complete
File: backend.py, railway_start.py
Required pattern:
python# In backend.py or railway_start.py
import os

# ✅ CORRECT: Dynamic port from environment
port = int(os.getenv('PORT', 5000))
app.run(host='0.0.0.0', port=port)

# ❌ WRONG: Hardcoded port
app.run(host='0.0.0.0', port=5000)
Verify:

 Port is read from PORT environment variable
 Host is set to '0.0.0.0' (not 'localhost' or '127.0.0.1')
 Railway health check points to correct port

1.5 Health Check Endpoint - complete
File: backend.py
Verify this endpoint exists and works:
python@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint for Railway"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'service': 'discord-bot-backend'
    }), 200
Test locally:
bashcurl http://localhost:5000/api/health
# Should return: {"status": "healthy", ...}
Verify:

 Endpoint returns 200 status
 No authentication required for health check
 railway.toml references correct health check path

1.6 Database Connection Handling - complete
File: core/data_manager.py, backend.py
Required patterns:
pythonfrom supabase import create_client, Client
import os

# ✅ CORRECT: Connection with error handling
try:
    supabase: Client = create_client(
        os.getenv('SUPABASE_URL'),
        os.getenv('SUPABASE_KEY')
    )
    # Test connection
    supabase.table('guilds').select('count', count='exact').execute()
except Exception as e:
    print(f"❌ Database connection failed: {e}")
    sys.exit(1)
Verify:

 Supabase client initialization has try-catch
 Connection is tested before app starts
 Proper error logging for connection failures
 No file-based fallback code in production paths

1.7 CORS Configuration - complete
File: backend.py
Verify CORS setup:
pythonfrom flask_cors import CORS

# ✅ For production with Netlify frontend
CORS(app, resources={
    r"/api/*": {
        "origins": [
            "https://your-netlify-domain.netlify.app",
            "http://localhost:3000"  # For local development
        ],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})

# ❌ WRONG: Insecure wildcard in production
CORS(app, origins="*")  # Don't use this
Verify:

 CORS is properly configured
 Netlify domain is whitelisted
 No wildcard origins in production
 Preflight OPTIONS requests are handled

1.8 File Upload Paths - complete
File: backend.py
Check all file operations:
python# Search for: open(), os.path, file uploads

# ✅ CORRECT: Use temp directories
import tempfile
upload_folder = tempfile.gettempdir()

# ❌ WRONG: Hardcoded paths that won't exist on Railway
upload_folder = './uploads'  # May not have write permissions
Verify:

 All file paths use environment variables or temp directories
 No hardcoded absolute paths
 File upload size limits are set
 Uploaded files are validated

1.9 Logging Configuration - complete
Files: All Python files
Required pattern:
pythonimport logging

# ✅ CORRECT: Structured logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(name)s: %(message)s',
    handlers=[logging.StreamHandler()]  # Railway captures stdout
)

logger = logging.getLogger(__name__)

# ❌ WRONG: File-based logging on Railway
logging.basicConfig(filename='bot.log')  # File system may be read-only
Verify:

 All logging goes to stdout/stderr
 No file-based logging
 Log levels are appropriate (INFO for production)
 Sensitive data is not logged

1.10 Async/Threading Issues - complete
Files: bot.py, backend.py
Check for:
python# Search for: threading.Thread, asyncio.run, async def

# ✅ CORRECT: Proper async handling
async def some_async_function():
    await some_operation()

# In sync context:
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
loop.run_until_complete(some_async_function())

# ❌ WRONG: Mixing sync and async improperly
def sync_function():
    await async_function()  # SyntaxError
Verify:

 No await outside async functions
 Event loops are properly managed
 No blocking operations in async functions
 Threading is properly synchronized


Part 2: Discord Bot Audit (bot.py, cogs/*.py) - complete
2.1 Intent Configuration
File: bot.py
Verify intents:
pythonimport discord

intents = discord.Intents.default()
intents.message_content = True  # Required for message commands
intents.members = True  # Required for member events
intents.guilds = True  # Required for guild events

bot = commands.Bot(command_prefix='!', intents=intents)
Check Discord Developer Portal:

 Privileged Gateway Intents are enabled:

 PRESENCE INTENT (if using presence)
 SERVER MEMBERS INTENT (if using member events)
 MESSAGE CONTENT INTENT (if using message commands)



2.2 Command Registration
Files: cogs/*.py
Verify all commands:
python# ✅ CORRECT: Proper command decorator
@app_commands.command(name="balance", description="Check your balance")
async def balance(self, interaction: discord.Interaction):
    await interaction.response.defer()
    # command logic

# ❌ WRONG: Missing defer for long operations
@app_commands.command()
async def long_operation(self, interaction: discord.Interaction):
    # This will timeout if it takes >3 seconds
    result = slow_operation()
    await interaction.response.send_message(result)
Verify:

 All slash commands use @app_commands.command()
 Long operations call await interaction.response.defer()
 All interactions are responded to within 3 seconds
 Error handlers are present for command errors

2.3 Rate Limit Handling
Files: cogs/*.py
Check for:
python# ✅ CORRECT: Handle rate limits
from discord import HTTPException

try:
    await channel.send("message")
except HTTPException as e:
    if e.status == 429:  # Rate limited
        logger.warning(f"Rate limited, retrying after {e.retry_after}s")
        await asyncio.sleep(e.retry_after)
        await channel.send("message")
    else:
        raise
Verify:

 Rate limit exceptions are caught
 Bulk operations are batched appropriately
 No rapid-fire message sending in loops

2.4 Permission Checks
Files: cogs/*.py
Verify permission checks:
python# ✅ CORRECT: Check permissions before operations
@app_commands.command()
@app_commands.checks.has_permissions(administrator=True)
async def admin_command(self, interaction: discord.Interaction):
    # admin logic
    pass

# Add error handler
@admin_command.error
async def admin_command_error(self, interaction: discord.Interaction, error):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("You lack permissions!", ephemeral=True)
Verify:

 Admin commands have permission decorators
 Permission errors are handled gracefully
 Bot has required permissions in guilds


Part 3: Frontend Audit (Netlify) - complete
3.1 API Endpoint Configuration
File: script.js
Verify API base URL:
javascript// ✅ CORRECT: Environment-based API URL
const API_BASE_URL = window.location.hostname === 'localhost'
    ? 'http://localhost:5000'
    : 'https://your-railway-app.railway.app';

// ❌ WRONG: Hardcoded localhost
const API_BASE_URL = 'http://localhost:5000';
Verify:

 API URL points to Railway deployment
 HTTPS is used in production
 No hardcoded localhost references

3.2 Authentication Token Handling
File: script.js
Verify JWT handling:
javascript// ✅ CORRECT: Store and send tokens properly
const token = localStorage.getItem('access_token');

fetch(`${API_BASE_URL}/api/endpoint`, {
    headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
    }
})
.then(response => {
    if (response.status === 401) {
        // Token expired, refresh or redirect to login
        refreshToken();
    }
    return response.json();
})
Verify:

 Tokens are stored securely
 Expired tokens trigger refresh
 Authorization header is included in all protected requests
 Token refresh logic is implemented

3.3 Error Handling
File: script.js
Verify error handling:
javascript// ✅ CORRECT: Comprehensive error handling
async function apiCall(endpoint, options = {}) {
    try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || `HTTP ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error('API Error:', error);
        showErrorToast(error.message);
        throw error;
    }
}
Verify:

 All fetch calls have try-catch
 Network errors are handled
 User-friendly error messages are shown
 Errors are logged for debugging

3.4 Netlify Configuration
File: netlify.toml
Verify configuration:
toml[build]
  publish = "."
  command = "echo 'No build needed for static site'"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    X-XSS-Protection = "1; mode=block"
    Referrer-Policy = "strict-origin-when-cross-origin"
Verify:

 Publish directory is correct
 SPA redirects are configured
 Security headers are present
 No sensitive data in public files


Part 4: Configuration Files Audit - complete
4.1 Railway Configuration
File: railway.toml
Required configuration:
toml[build]
  builder = "nixpacks"
  buildCommand = "pip install -r requirements.txt"

[deploy]
  startCommand = "python railway_start.py"
  restartPolicyType = "on-failure"
  restartPolicyMaxRetries = 3

[healthcheck]
  path = "/api/health"
  timeout = 300
Verify:

 Health check path is correct
 Start command is correct
 Restart policy is configured
 Build command installs all dependencies

4.2 Requirements File
File: requirements.txt
Verify all dependencies:
txtdiscord.py>=2.3.0
flask>=3.0.0
flask-cors>=4.0.0
flask-jwt-extended>=4.5.0
supabase>=2.0.0
python-dotenv>=1.0.0
bcrypt>=4.0.0
aiohttp>=3.9.0
Check:

 All imports in code are listed
 Version pins are present
 No conflicting dependencies
 No development-only packages in production

4.3 Environment File Template
File: .env.example
Create this file:
bash# Discord Bot Configuration
DISCORD_TOKEN=your_discord_bot_token_here
DISCORD_CLIENT_ID=your_client_id_here

# Supabase Database
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_KEY=your_supabase_service_role_key_here

# Flask Backend
JWT_SECRET_KEY=your_random_secret_key_here
FLASK_ENV=production
PORT=5000

# Admin Credentials (First time setup)
ADMIN_USERNAME=admin
ADMIN_PASSWORD=change_this_password
Verify:

 .env.example exists for documentation
 .env is in .gitignore
 Railway environment variables match template
 No secrets committed to git


Part 5: Security Audit - complete
5.1 SQL Injection Prevention
File: core/data_manager.py
Verify parameterized queries:
python# ✅ CORRECT: Parameterized query
supabase.table('users').select('*').eq('user_id', user_id).execute()

# ❌ WRONG: String concatenation
supabase.table('users').select('*').eq('user_id', f'{user_id}').execute()
Verify:

 No raw SQL string concatenation
 All queries use Supabase client methods
 User inputs are validated before queries

5.2 Input Validation
Files: All API endpoints in backend.py
Check every endpoint:
python# ✅ CORRECT: Input validation
@app.route('/api/<server_id>/users/<user_id>/balance', methods=['PUT'])
@jwt_required()
def update_balance(server_id, user_id):
    data = request.get_json()
    
    if not data or 'amount' not in data:
        return jsonify({'error': 'Amount is required'}), 400
    
    try:
        amount = int(data['amount'])
        if amount < 0:
            return jsonify({'error': 'Amount must be positive'}), 400
    except ValueError:
        return jsonify({'error': 'Invalid amount'}), 400
    
    # Process request
Verify:

 All inputs are validated
 Type checking is performed
 Range checking for numbers
 String length limits enforced

5.3 Authentication Bypass Check
File: backend.py
Verify all protected endpoints:
python# Search for: @app.route

# ✅ CORRECT: Protected endpoint
@app.route('/api/protected', methods=['GET'])
@jwt_required()
def protected_endpoint():
    pass

# ❌ WRONG: Missing authentication
@app.route('/api/admin/users', methods=['DELETE'])  # No @jwt_required()
def delete_user():
    pass
Verify:

 All admin endpoints have @jwt_required()
 Public endpoints are intentionally public
 No authentication bypass vulnerabilities

5.4 Secrets Exposure Check
Run this command:
bash# Search for hardcoded secrets
grep -r "password.*=" . --include="*.py" --include="*.js"
grep -r "token.*=" . --include="*.py" --include="*.js"
grep -r "api_key.*=" . --include="*.py" --include="*.js"
grep -r "secret.*=" . --include="*.py" --include="*.js"
Verify:

 No hardcoded passwords
 No API keys in code
 All secrets from environment variables
 .env is in .gitignore


Part 6: Performance & Reliability - complete
6.1 Memory Leaks
Files: bot.py, backend.py, cogs/*.py
Check for:
python# ❌ WRONG: Unbounded cache growth
cache = {}  # Never cleared
def get_data(key):
    if key not in cache:
        cache[key] = fetch_data(key)  # Cache grows forever
    return cache[key]

# ✅ CORRECT: TTL-based cache
from functools import lru_cache
from datetime import datetime, timedelta

@lru_cache(maxsize=1000)  # Limited size
def get_data(key):
    return fetch_data(key)
Verify:

 Caches have size limits
 Old data is purged
 No circular references
 Event listeners are properly cleaned up

6.2 Database Connection Pool
File: core/data_manager.py
Verify:
python# ✅ CORRECT: Reuse Supabase client
class DataManager:
    def __init__(self):
        self.supabase = create_client(url, key)  # One client instance
    
    def query(self):
        return self.supabase.table('users').select('*').execute()

# ❌ WRONG: Create new client every query
def query():
    supabase = create_client(url, key)  # Creates new connection
    return supabase.table('users').select('*').execute()
Verify:

 Supabase client is singleton
 Connections are reused
 No connection leaks

6.3 Error Recovery
Files: All Python files
Verify error handlers:
python# ✅ CORRECT: Graceful degradation
try:
    result = critical_operation()
except Exception as e:
    logger.error(f"Operation failed: {e}")
    # Fallback behavior
    result = default_value

# ❌ WRONG: Unhandled exceptions crash app
result = critical_operation()  # May throw exception
Verify:

 Critical sections have try-catch
 Exceptions are logged
 Graceful degradation where possible
 App doesn't crash on single error


Part 7: Pre-Deployment Testing - complete
7.1 Local Test Checklist
bash# 1. Start backend locally
python railway_start.py
# Should see: "Flask app running on port 5000"

# 2. Test health check
curl http://localhost:5000/api/health
# Should return: {"status": "healthy"}

# 3. Test Discord bot
python bot.py
# Should see: "Bot is ready!"

# 4. Open frontend
open index.html
# Should load without console errors

# 5. Test authentication
# Login through web dashboard
# Verify JWT tokens in browser DevTools > Application > Local Storage

# 6. Test API calls
# Perform CRUD operations through dashboard
# Check Railway logs for errors
Verify:

 Flask starts without errors
 Health check responds
 Discord bot connects
 Frontend loads
 Authentication works
 API calls succeed

7.2 Railway Deployment Test
bash# 1. Push to Railway
git push

# 2. Monitor deployment logs
# Railway Dashboard > Deployments > View Logs

# 3. Test health check
curl https://your-app.railway.app/api/health

# 4. Test Discord bot
# Send command in Discord server
# Check bot responds

# 5. Test web dashboard
# Open Railway deployment URL
# Login and perform operations
Verify:

 Deployment succeeds
 Health check passes
 Discord bot online
 Dashboard accessible
 All features work

7.3 Integration Test
Test these user flows:

User Registration Flow:

 User joins Discord server
 Bot creates user record
 User appears in dashboard


Currency Flow:

 User claims daily reward
 Balance updates correctly
 Transaction logged in database


Task Flow:

 Admin creates task via dashboard
 Task appears in Discord
 User claims task
 User submits proof
 Admin approves
 Reward is granted


Shop Flow:

 Admin adds shop item
 Item appears in Discord shop
 User purchases item
 Balance deducted
 Item added to inventory




Part 8: Final Checklist - complete
Production Readiness

 All Flask endpoints have unique endpoint names
 All decorators use @functools.wraps(f)
 Environment variables are set in Railway
 Health check endpoint works
 Port is dynamically assigned from PORT env var
 CORS is properly configured
 Database connection is validated on startup
 All secrets are from environment variables
 Logging goes to stdout (not files)
 No hardcoded paths or URLs

Security

 No SQL injection vulnerabilities
 All inputs are validated
 Protected endpoints have authentication
 No secrets in code or git
 Security headers are set
 JWT tokens have expiration
 HTTPS is enforced in production

Performance

 Caches have size limits
 Database connections are pooled
 No memory leaks
 Rate limits are handled
 Long operations are deferred

Reliability

 Error handlers are present
 Exceptions are logged
 Graceful degradation is implemented
 Health check is reliable
 Restart policy is configured

Testing

 Local tests pass
 Railway deployment succeeds
 Discord bot connects
 Dashboard is accessible
 All user flows work end-to-end


Emergency Rollback Plan
If deployment fails:

Check Railway Logs:

bash   railway logs

Roll back to last working commit:

bash   git revert HEAD
   git push

Check environment variables:

bash   railway variables

Restart service:

bash   railway restart

Contact support if needed:

Railway: https://railway.app/help
Discord API: https://discord.com/developers/docs




Success Criteria
✅ Backend (Railway):

Flask app starts without errors
Health check returns 200 OK
All API endpoints respond correctly
Database connection is stable

✅ Bot (Railway):

Bot connects to Discord
Slash commands work
Task system functional
Shop system operational

✅ Frontend (Netlify):

Dashboard loads without errors
API calls succeed
Authentication works
Real-time updates function

✅ Integration:

End-to-end user flows complete successfully
Data persists correctly
No runtime errors
Performance is acceptable

Run this entire audit before deploying to production. This code WILL work if you follow every step.

complete
