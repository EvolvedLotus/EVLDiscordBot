Cursor AI Prompt: Complete Bot Functionality - Supabase Sync & Discord Command Parity
Overview
Fix remaining deployment issues AND implement two major enhancements:

Hourly Supabase sync with initial sync on startup for guilds, users, and all data
Full Discord command parity with CMS dashboard - everything doable in the web dashboard should be available via Discord commands


Part 1: Fix Remaining Deployment Issues - COMPLETE ‚úÖ

Issue #1: SSE Background Threads Using time Instead of time_module - FIXED ‚úÖ
File: backend.py (lines ~3575 and ~3585)
Replaced time.sleep() with time_module.sleep() in both process_batches() and send_keepalive() methods.

Issue #2: Missing TaskManager Import - FIXED ‚úÖ
File: cogs/tasks.py
Added import: from core.task_manager import TaskManager

Issue #3: Missing get_cache_stats Method - FIXED ‚úÖ
File: core/data_manager.py
Added get_cache_stats() and _calculate_hit_rate() methods to DataManager class.

Part 2: Implement Hourly Supabase Sync System
Step 1: Create Comprehensive Sync Method in DataManager
File: core/data_manager.py
Add this method to DataManager class:
pythonasync def sync_all_guilds(self, bot=None):
    """
    Comprehensive sync of all guild data from Discord to Supabase
    Runs on startup and every hour
    """
    logger.info("üîÑ Starting comprehensive guild sync...")
    
    if not bot or not bot.is_ready():
        logger.warning("Bot not ready, skipping sync")
        return {'success': False, 'error': 'Bot not ready'}
    
    sync_stats = {
        'guilds_synced': 0,
        'users_synced': 0,
        'channels_synced': 0,
        'roles_synced': 0,
        'errors': []
    }
    
    try:
        # Get all guilds bot is connected to
        for guild in bot.guilds:
            try:
                logger.info(f"Syncing guild: {guild.name} (ID: {guild.id})")
                
                # 1. Sync guild information
                guild_data = {
                    'guild_id': str(guild.id),
                    'server_name': guild.name,
                    'owner_id': str(guild.owner_id),
                    'member_count': guild.member_count,
                    'icon_url': str(guild.icon.url) if guild.icon else None,
                    'is_active': True,
                    'updated_at': datetime.utcnow().isoformat()
                }
                
                # Upsert guild
                self.supabase.table('guilds').upsert(guild_data).execute()
                sync_stats['guilds_synced'] += 1
                
                # 2. Sync all members (users)
                member_count = 0
                for member in guild.members:
                    if member.bot:
                        continue  # Skip bots
                    
                    try:
                        user_data = {
                            'user_id': str(member.id),
                            'guild_id': str(guild.id),
                            'is_active': True,
                            'updated_at': datetime.utcnow().isoformat()
                        }
                        
                        # Check if user exists, if not create with default balance
                        existing = self.supabase.table('users').select('*').eq('user_id', str(member.id)).eq('guild_id', str(guild.id)).execute()
                        
                        if not existing.data:
                            user_data['balance'] = 0
                            user_data['total_earned'] = 0
                            user_data['total_spent'] = 0
                            user_data['created_at'] = datetime.utcnow().isoformat()
                        
                        self.supabase.table('users').upsert(user_data).execute()
                        member_count += 1
                    except Exception as e:
                        logger.error(f"Error syncing member {member.id}: {e}")
                        sync_stats['errors'].append(f"Member {member.id}: {str(e)}")
                
                sync_stats['users_synced'] += member_count
                logger.info(f"‚úì Synced {member_count} members from {guild.name}")
                
                # 3. Initialize task_settings if not exists
                try:
                    task_settings_exists = self.supabase.table('task_settings').select('*').eq('guild_id', str(guild.id)).execute()
                    if not task_settings_exists.data:
                        self.supabase.table('task_settings').insert({
                            'guild_id': str(guild.id),
                            'allow_user_tasks': True,
                            'max_tasks_per_user': 10,
                            'auto_expire_enabled': True,
                            'require_proof': True,
                            'next_task_id': 1,
                            'created_at': datetime.utcnow().isoformat()
                        }).execute()
                except Exception as e:
                    logger.error(f"Error initializing task_settings for {guild.id}: {e}")
                
            except Exception as e:
                logger.error(f"Error syncing guild {guild.id}: {e}")
                sync_stats['errors'].append(f"Guild {guild.id}: {str(e)}")
        
        logger.info(f"‚úÖ Sync completed: {sync_stats['guilds_synced']} guilds, {sync_stats['users_synced']} users")
        return {'success': True, 'stats': sync_stats}
        
    except Exception as e:
        logger.error(f"Critical error during sync: {e}")
        return {'success': False, 'error': str(e), 'stats': sync_stats}

async def mark_inactive_guilds(self, bot):
    """Mark guilds the bot is no longer in as inactive"""
    if not bot or not bot.is_ready():
        return
    
    try:
        # Get all guilds from database
        db_guilds = self.supabase.table('guilds').select('guild_id').execute()
        db_guild_ids = {g['guild_id'] for g in db_guilds.data}
        
        # Get current bot guilds
        bot_guild_ids = {str(g.id) for g in bot.guilds}
        
        # Find guilds bot left
        left_guilds = db_guild_ids - bot_guild_ids
        
        if left_guilds:
            logger.info(f"Marking {len(left_guilds)} guilds as inactive")
            for guild_id in left_guilds:
                self.supabase.table('guilds').update({
                    'is_active': False,
                    'left_at': datetime.utcnow().isoformat()
                }).eq('guild_id', guild_id).execute()
    except Exception as e:
        logger.error(f"Error marking inactive guilds: {e}")

Step 2: Add Hourly Sync Background Task to Bot
File: bot.py
Find the background tasks section and add this new task:
python@tasks.loop(hours=1)
async def hourly_sync_job():
    """Sync all guild data with Supabase every hour"""
    try:
        logger.info("üîÑ Running hourly Supabase sync...")
        result = await data_manager.sync_all_guilds(bot)
        
        if result.get('success'):
            stats = result.get('stats', {})
            logger.info(f"‚úÖ Hourly sync completed - Guilds: {stats.get('guilds_synced', 0)}, Users: {stats.get('users_synced', 0)}")
            
            if stats.get('errors'):
                logger.warning(f"‚ö†Ô∏è  Sync had {len(stats['errors'])} errors")
        else:
            logger.error(f"‚ùå Hourly sync failed: {result.get('error')}")
            
    except Exception as e:
        logger.error(f"Error in hourly sync job: {e}", exc_info=True)

@hourly_sync_job.before_loop
async def before_hourly_sync():
    """Wait for bot to be ready before starting hourly sync"""
    await bot.wait_until_ready()
    logger.info("Bot ready, starting hourly sync job")

# Start the hourly sync task
@bot.event
async def on_ready():
    # ... existing on_ready code ...
    
    # Start hourly sync
    if not hourly_sync_job.is_running():
        hourly_sync_job.start()
        logger.info("Hourly sync job initialized")
    
    # Run initial sync on startup
    logger.info("üöÄ Running initial startup sync...")
    await data_manager.sync_all_guilds(bot)
    await data_manager.mark_inactive_guilds(bot)
    logger.info("‚úÖ Initial startup sync completed")

Part 3: Discord Command Parity with CMS Dashboard
Step 1: Create Admin Cog with Full CMS Feature Parity
File: cogs/admin.py (or create new file cogs/bot_admin.py)
Add these commands to match ALL CMS features:
pythonimport discord
from discord import app_commands
from discord.ext import commands
from typing import Optional, Literal
import logging

logger = logging.getLogger(__name__)

class BotAdmin(commands.Cog):
    """Administrative commands with full CMS feature parity"""
    
    def __init__(self, bot):
        self.bot = bot
        self.data_manager = bot.data_manager
    
    # ============================================
    # BOT STATUS MANAGEMENT (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="bot_status", description="Change bot's Discord status")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        status="Bot status type",
        activity="Activity type",
        text="Status message"
    )
    async def bot_status(
        self, 
        interaction: discord.Interaction,
        status: Literal["online", "idle", "dnd", "invisible"],
        activity: Literal["playing", "watching", "listening", "streaming"],
        text: str
    ):
        """Change bot status and activity (CMS: Bot Management > Status)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            # Map status strings to Discord status
            status_map = {
                "online": discord.Status.online,
                "idle": discord.Status.idle,
                "dnd": discord.Status.dnd,
                "invisible": discord.Status.invisible
            }
            
            # Map activity strings to Discord activity types
            activity_map = {
                "playing": discord.ActivityType.playing,
                "watching": discord.ActivityType.watching,
                "listening": discord.ActivityType.listening,
                "streaming": discord.ActivityType.streaming
            }
            
            discord_status = status_map[status]
            discord_activity = discord.Activity(type=activity_map[activity], name=text)
            
            await self.bot.change_presence(status=discord_status, activity=discord_activity)
            
            await interaction.followup.send(
                f"‚úÖ Bot status updated!\n"
                f"**Status:** {status}\n"
                f"**Activity:** {activity} {text}",
                ephemeral=True
            )
            
            logger.info(f"Bot status changed by {interaction.user.id}: {status} - {activity} {text}")
            
        except Exception as e:
            logger.error(f"Error changing bot status: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ============================================
    # SERVER CONFIGURATION (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="config_currency", description="Configure server currency settings")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        currency_name="Name of the currency (e.g., coins, points)",
        currency_symbol="Symbol for the currency (e.g., $, ‚≠ê)"
    )
    async def config_currency(
        self,
        interaction: discord.Interaction,
        currency_name: str,
        currency_symbol: str
    ):
        """Configure currency name and symbol (CMS: Settings > Currency)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Update in database
            self.data_manager.supabase.table('guilds').update({
                'currency_name': currency_name,
                'currency_symbol': currency_symbol,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            await interaction.followup.send(
                f"‚úÖ Currency settings updated!\n"
                f"**Name:** {currency_name}\n"
                f"**Symbol:** {currency_symbol}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="config_channels", description="Set special channels for bot features")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        channel_type="Type of channel to set",
        channel="The channel to use"
    )
    async def config_channels(
        self,
        interaction: discord.Interaction,
        channel_type: Literal["task", "shop", "log", "welcome"],
        channel: discord.TextChannel
    ):
        """Configure special channels (CMS: Settings > Channels)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Map channel type to database column
            column_map = {
                "task": "task_channel_id",
                "shop": "shop_channel_id",
                "log": "log_channel",
                "welcome": "welcome_channel"
            }
            
            column = column_map[channel_type]
            
            self.data_manager.supabase.table('guilds').update({
                column: str(channel.id),
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            await interaction.followup.send(
                f"‚úÖ {channel_type.title()} channel set to {channel.mention}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="config_features", description="Enable/disable bot features")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        feature="Feature to toggle",
        enabled="Enable or disable"
    )
    async def config_features(
        self,
        interaction: discord.Interaction,
        feature: Literal["currency", "tasks", "shop", "announcements", "moderation"],
        enabled: bool
    ):
        """Toggle bot features on/off (CMS: Settings > Features)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            column = f"feature_{feature}"
            
            self.data_manager.supabase.table('guilds').update({
                column: enabled,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            status = "enabled" if enabled else "disabled"
            await interaction.followup.send(
                f"‚úÖ {feature.title()} feature has been **{status}**",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ============================================
    # USER MANAGEMENT (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="user_balance_set", description="Set a user's balance")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        user="User to modify",
        amount="New balance amount",
        reason="Reason for balance change"
    )
    async def user_balance_set(
        self,
        interaction: discord.Interaction,
        user: discord.Member,
        amount: int,
        reason: Optional[str] = "Admin modification"
    ):
        """Set user balance directly (CMS: Users > Edit Balance)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            user_id = str(user.id)
            
            # Get current balance
            current = self.data_manager.supabase.table('users').select('balance').eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            if not current.data:
                await interaction.followup.send(f"‚ùå User not found in database", ephemeral=True)
                return
            
            old_balance = current.data[0]['balance']
            difference = amount - old_balance
            
            # Update balance
            self.data_manager.supabase.table('users').update({
                'balance': amount,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            # Log transaction
            self.data_manager.log_transaction(
                guild_id=guild_id,
                user_id=user_id,
                amount=difference,
                transaction_type='admin_set',
                description=f"Balance set by {interaction.user.name}: {reason}"
            )
            
            await interaction.followup.send(
                f"‚úÖ Balance updated for {user.mention}\n"
                f"**Old Balance:** {old_balance}\n"
                f"**New Balance:** {amount}\n"
                f"**Difference:** {difference:+d}\n"
                f"**Reason:** {reason}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="user_stats", description="View detailed user statistics")
    @app_commands.describe(user="User to view stats for")
    async def user_stats(self, interaction: discord.Interaction, user: discord.Member):
        """View comprehensive user stats (CMS: Users > View Details)"""
        await interaction.response.defer()
        
        try:
            guild_id = str(interaction.guild_id)
            user_id = str(user.id)
            
            # Get user data
            user_data = self.data_manager.supabase.table('users').select('*').eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            if not user_data.data:
                await interaction.followup.send("‚ùå User not found in database")
                return
            
            data = user_data.data[0]
            
            # Get transaction count
            transactions = self.data_manager.supabase.table('transactions').select('*', count='exact').eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            # Get inventory count
            inventory = self.data_manager.supabase.table('inventory').select('*', count='exact').eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            # Get active tasks
            tasks = self.data_manager.supabase.table('user_tasks').select('*', count='exact').eq('user_id', user_id).eq('guild_id', guild_id).eq('status', 'in_progress').execute()
            
            embed = discord.Embed(
                title=f"üìä User Statistics: {user.display_name}",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=user.display_avatar.url)
            
            embed.add_field(name="üí∞ Balance", value=f"{data['balance']:,}", inline=True)
            embed.add_field(name="üìà Total Earned", value=f"{data['total_earned']:,}", inline=True)
            embed.add_field(name="üìâ Total Spent", value=f"{data['total_spent']:,}", inline=True)
            embed.add_field(name="üî¢ Transactions", value=f"{transactions.count}", inline=True)
            embed.add_field(name="üéí Inventory Items", value=f"{inventory.count}", inline=True)
            embed.add_field(name="üìã Active Tasks", value=f"{tasks.count}", inline=True)
            embed.add_field(name="üìÖ Joined", value=f"<t:{int(datetime.fromisoformat(data['created_at'].replace('Z', '+00:00')).timestamp())}:R>", inline=True)
            embed.add_field(name="üîÑ Last Updated", value=f"<t:{int(datetime.fromisoformat(data['updated_at'].replace('Z', '+00:00')).timestamp())}:R>", inline=True)
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}")
    
    # ============================================
    # ANNOUNCEMENT MANAGEMENT (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="announce", description="Create a server announcement")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        channel="Channel to post announcement",
        title="Announcement title",
        content="Announcement content",
        pin="Pin the announcement"
    )
    async def announce(
        self,
        interaction: discord.Interaction,
        channel: discord.TextChannel,
        title: str,
        content: str,
        pin: bool = False
    ):
        """Create announcement (CMS: Announcements > Create)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            embed = discord.Embed(
                title=title,
                description=content,
                color=discord.Color.blue(),
                timestamp=datetime.utcnow()
            )
            embed.set_footer(text=f"Announced by {interaction.user.display_name}", icon_url=interaction.user.display_avatar.url)
            
            message = await channel.send(embed=embed)
            
            if pin:
                await message.pin()
            
            # Save to database
            announcement_id = f"ann_{int(datetime.utcnow().timestamp())}"
            self.data_manager.supabase.table('announcements').insert({
                'announcement_id': announcement_id,
                'guild_id': str(interaction.guild_id),
                'title': title,
                'content': content,
                'channel_id': str(channel.id),
                'message_id': str(message.id),
                'is_pinned': pin,
                'created_by': str(interaction.user.id),
                'created_at': datetime.utcnow().isoformat()
            }).execute()
            
            await interaction.followup.send(
                f"‚úÖ Announcement posted in {channel.mention}\n"
                f"{'üìå Message pinned' if pin else ''}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ============================================
    # SHOP MANAGEMENT (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="shop_add", description="Add item to shop")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        name="Item name",
        price="Item price",
        description="Item description",
        stock="Stock amount (-1 for unlimited)",
        category="Item category"
    )
    async def shop_add(
        self,
        interaction: discord.Interaction,
        name: str,
        price: int,
        description: str,
        stock: int = -1,
        category: str = "general"
    ):
        """Add item to shop (CMS: Shop > Add Item)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            item_id = f"item_{int(datetime.utcnow().timestamp())}"
            
            self.data_manager.supabase.table('shop_items').insert({
                'item_id': item_id,
                'guild_id': guild_id,
                'name': name,
                'description': description,
                'price': price,
                'stock': stock,
                'category': category,
                'is_active': True,
                'created_at': datetime.utcnow().isoformat()
            }).execute()
            
            await interaction.followup.send(
                f"‚úÖ Item added to shop!\n"
                f"**Name:** {name}\n"
                f"**Price:** {price}\n"
                f"**Stock:** {'Unlimited' if stock == -1 else stock}\n"
                f"**Category:** {category}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="shop_remove", description="Remove item from shop")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(item_name="Name of item to remove")
    async def shop_remove(
        self,
        interaction: discord.Interaction,
        item_name: str
    ):
        """Remove item from shop (CMS: Shop > Delete)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Find item
            item = self.data_manager.supabase.table('shop_items').select('*').eq('guild_id', guild_id).ilike('name', item_name).execute()
            
            if not item.data:
                await interaction.followup.send(f"‚ùå Item '{item_name}' not found", ephemeral=True)
                return
            
            # Delete item
            self.data_manager.supabase.table('shop_items').delete().eq('id', item.data[0]['id']).execute()
            
            await interaction.followup.send(f"‚úÖ Item '{item_name}' removed from shop", ephemeral=True)
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ============================================
    # SYSTEM MANAGEMENT (Like CMS Dashboard)
    # ============================================
    
    @app_commands.command(name="sync_now", description="Force sync with Supabase")
    @app_commands.checks.has_permissions(administrator=True)
    async def sync_now(self, interaction: discord.Interaction):
        """Manually trigger Supabase sync (CMS: System > Sync)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            result = await self.data_manager.sync_all_guilds(self.bot)
            
            if result.get('success'):
                stats = result.get('stats', {})
                await interaction.followup.send(
                    f"‚úÖ Sync completed!\n"
                    f"**Guilds:** {stats.get('guilds_synced', 0)}\n"
                    f"**Users:** {stats.get('users_synced', 0)}\n"
                    f"**Errors:** {len(stats.get('errors', []))}",
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    f"‚ùå Sync failed: {result.get('error')}",
                    ephemeral=True
                )
                
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="stats_server", description="View server statistics")
    @app_commands.checks.has_permissions(administrator=True)
    async def stats_server(self, interaction: discord.Interaction):
        """View comprehensive server stats (CMS: Overview)"""
        await interaction.response.defer()
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Get stats from database
            users = self.data_manager.supabase.table('users').select('*', count='exact').eq('guild_id', guild_id).execute()
            tasks = self.data_manager.supabase.table('tasks').select('*', count='exact').eq('guild_id', guild_id).execute()
            shop_items = self.data_manager.supabase.table('shop_items').select('*', count='exact').eq('guild_id', guild_id).execute()
            transactions = self.data_manager.supabase.table('transactions').select('*', count='exact').eq('guild_id', guild_id).execute()
            
            # Calculate total economy
            total_balance = sum(u.get('balance', 0) for u in users.RetryYou reached the start of the range
Nov 17, 2025, 2:40 PM
Starting Container
[2025-11-17 19:41:36,816] [INFO] __main__: ‚úÖ DISCORD_TOKEN found
[2025-11-17 19:41:36,817] [INFO] __main__: ==================================================
[2025-11-17 19:41:36,817] [INFO] __main__: ü§ñ Discord EconompastedNtweak it, that active one i said has this as its full logCursor AI Prompt: Complete Bot Enhancement - Sync System, Discord Command Parity & Bug Fixes
Mission
Fix 3 critical bugs from Railway logs AND implement 2 major feature enhancements:

Fix remaining time module errors in SSE threads
Fix TaskManager import error preventing tasks cog from loading
Fix missing cache methods causing cleanup errors
Implement hourly Supabase sync with startup sync for all guilds/users/data
Add full Discord command parity with CMS - every dashboard feature accessible via slash commands


Part 1: Critical Bug Fixes
Bug Fix #1: SSE Thread Time Module Errors
Error in logs:
Exception in thread Thread-2 (process_batches):
NameError: name 'time' is not defined
  File "/app/backend.py", line 3575, in process_batches
    time.sleep(self.BATCH_INTERVAL)

Exception in thread Thread-3 (send_keepalive):
NameError: name 'time' is not defined
  File "/app/backend.py", line 3585, in send_keepalive
    time.sleep(self.KEEPALIVE_INTERVAL)
File: backend.py
Search for these two methods around lines 3570-3590:
pythondef process_batches(self):
    """Background thread to process SSE event batches"""
    while self.running:
        # ... batch processing code ...
        time.sleep(self.BATCH_INTERVAL)  # ‚ùå Line 3575

def send_keepalive(self):
    """Send periodic keepalive comments to SSE clients"""
    while self.running:
        # ... keepalive code ...
        time.sleep(self.KEEPALIVE_INTERVAL)  # ‚ùå Line 3585
Replace ALL time.sleep( with time_module.sleep( in these two methods:
pythondef process_batches(self):
    """Background thread to process SSE event batches"""
    while self.running:
        # ... batch processing code ...
        time_module.sleep(self.BATCH_INTERVAL)  # ‚úÖ Fixed

def send_keepalive(self):
    """Send periodic keepalive comments to SSE clients"""
    while self.running:
        # ... keepalive code ...
        time_module.sleep(self.KEEPALIVE_INTERVAL)  # ‚úÖ Fixed
```

**Quick fix using Find & Replace in backend.py ONLY in the SSEBroadcaster class:**
- Find: `time.sleep(self.BATCH_INTERVAL)`
- Replace: `time_module.sleep(self.BATCH_INTERVAL)`
- Find: `time.sleep(self.KEEPALIVE_INTERVAL)`
- Replace: `time_module.sleep(self.KEEPALIVE_INTERVAL)`

---

### Bug Fix #2: TaskManager Import Error

**Error in logs:**
```
[ERROR] bot: ‚úó Failed to load tasks cog: Extension 'cogs.tasks' raised an error: NameError: name 'TaskManager' is not defined
File: cogs/tasks.py
Step 1: Find where TaskManager is actually defined
bash# Run this to locate TaskManager
grep -r "class TaskManager" . --include="*.py"
Step 2a: If TaskManager exists in core/task_manager.py
Add to imports at top of cogs/tasks.py:
pythonfrom core.task_manager import TaskManager
Step 2b: If TaskManager exists in core/tasks.py
Add to imports at top of cogs/tasks.py:
pythonfrom core.tasks import TaskManager
Step 2c: If TaskManager doesn't exist anywhere
The tasks cog is trying to use a class that doesn't exist. You have two options:
Option 1: Create TaskManager (if needed)
Create core/task_manager.py:
pythonimport logging
from datetime import datetime

logger = logging.getLogger(__name__)

class TaskManager:
    """Manages task operations and validation"""
    
    def __init__(self, data_manager):
        self.data_manager = data_manager
        logger.info("TaskManager initialized")
    
    def get_active_tasks(self, guild_id):
        """Get all active tasks for a guild"""
        try:
            response = self.data_manager.supabase.table('tasks')\
                .select('*')\
                .eq('guild_id', str(guild_id))\
                .eq('status', 'active')\
                .execute()
            return response.data
        except Exception as e:
            logger.error(f"Error getting active tasks: {e}")
            return []
```

**Option 2: Remove TaskManager dependency from tasks cog**
Open `cogs/tasks.py` and replace `TaskManager` usage with direct `data_manager` calls.

---

### Bug Fix #3: Missing Cache Methods

**Error in logs:**
```
[ERROR] bot: Error during cache cleanup: 'DataManager' object has no attribute 'get_cache_stats'
File: core/data_manager.py
Add these methods to the DataManager class:
pythondef get_cache_stats(self):
    """Get cache statistics for monitoring"""
    if not hasattr(self, '_cache'):
        self._cache = {}
    
    if not hasattr(self, '_cache_hits'):
        self._cache_hits = 0
    
    if not hasattr(self, '_cache_misses'):
        self._cache_misses = 0
    
    return {
        'size': len(self._cache),
        'max_size': getattr(self, '_cache_max_size', 1000),
        'hit_rate': self._calculate_hit_rate(),
        'keys_sample': list(self._cache.keys())[:10]  # First 10 keys
    }

def _calculate_hit_rate(self):
    """Calculate cache hit rate percentage"""
    total = self._cache_hits + self._cache_misses
    if total == 0:
        return 0.0
    return round((self._cache_hits / total) * 100, 2)

def clear_expired_cache(self):
    """Remove expired entries from cache"""
    if not hasattr(self, '_cache'):
        self._cache = {}
        return 0
    
    now = datetime.utcnow()
    expired_keys = []
    
    for key, value in list(self._cache.items()):
        if isinstance(value, dict) and 'expires_at' in value:
            try:
                expires = datetime.fromisoformat(value['expires_at'].replace('Z', '+00:00'))
                if expires < now:
                    expired_keys.append(key)
            except:
                pass
    
    for key in expired_keys:
        del self._cache[key]
    
    if expired_keys:
        logger.info(f"Cleared {len(expired_keys)} expired cache entries")
    
    return len(expired_keys)
Also update bot.py cache cleanup job:
File: bot.py
Find the cache cleanup job and update it:
python@tasks.loop(hours=1)
async def cache_cleanup_job():
    """Clean expired cache entries every hour"""
    try:
        logger.info("Running cache cleanup job...")
        
        # Get cache stats before cleanup
        if hasattr(data_manager, 'get_cache_stats'):
            stats = data_manager.get_cache_stats()
            logger.info(f"Cache stats before cleanup: {stats['size']} entries, {stats['hit_rate']}% hit rate")
        
        # Perform cleanup
        if hasattr(data_manager, 'clear_expired_cache'):
            cleared = data_manager.clear_expired_cache()
            logger.info(f"‚úÖ Cache cleanup completed: {cleared} expired entries removed")
        else:
            logger.warning("clear_expired_cache method not available")
            
    except Exception as e:
        logger.error(f"Error during cache cleanup: {e}", exc_info=True)

@cache_cleanup_job.before_loop
async def before_cache_cleanup():
    """Wait for bot to be ready"""
    await bot.wait_until_ready()

Part 2: Hourly Supabase Sync System
Step 1: Add Comprehensive Sync Method to DataManager
File: core/data_manager.py
Add this complete sync system to DataManager class:
pythonasync def sync_all_guilds(self, bot=None):
    """
    Comprehensive sync of all Discord guilds to Supabase
    - Runs on bot startup
    - Runs every hour via background task
    - Syncs guilds, members, channels, roles
    """
    from datetime import datetime
    
    if not bot or not bot.is_ready():
        logger.warning("‚ö†Ô∏è  Bot not ready for sync, skipping")
        return {'success': False, 'error': 'Bot not ready'}
    
    logger.info("=" * 60)
    logger.info("üîÑ STARTING COMPREHENSIVE GUILD SYNC")
    logger.info("=" * 60)
    
    sync_stats = {
        'guilds_synced': 0,
        'guilds_updated': 0,
        'members_synced': 0,
        'members_created': 0,
        'members_updated': 0,
        'channels_found': 0,
        'roles_found': 0,
        'errors': [],
        'start_time': datetime.utcnow().isoformat(),
    }
    
    try:
        bot_guilds = list(bot.guilds)
        logger.info(f"üìä Found {len(bot_guilds)} guilds to sync")
        
        for guild in bot_guilds:
            try:
                logger.info(f"üîÑ Syncing guild: {guild.name} (ID: {guild.id})")
                
                # === SYNC GUILD INFO ===
                guild_data = {
                    'guild_id': str(guild.id),
                    'server_name': guild.name,
                    'owner_id': str(guild.owner_id),
                    'member_count': guild.member_count,
                    'icon_url': str(guild.icon.url) if guild.icon else None,
                    'is_active': True,
                    'updated_at': datetime.utcnow().isoformat()
                }
                
                # Check if guild exists
                existing = self.supabase.table('guilds').select('*').eq('guild_id', str(guild.id)).execute()
                
                if existing.data:
                    # Update existing guild
                    self.supabase.table('guilds').update(guild_data).eq('guild_id', str(guild.id)).execute()
                    sync_stats['guilds_updated'] += 1
                    logger.info(f"  ‚úì Updated guild {guild.name}")
                else:
                    # Insert new guild with defaults
                    guild_data.update({
                        'prefix': '!',
                        'currency_name': 'coins',
                        'currency_symbol': '$',
                        'feature_currency': True,
                        'feature_tasks': True,
                        'feature_shop': True,
                        'feature_announcements': True,
                        'feature_moderation': True,
                        'created_at': datetime.utcnow().isoformat()
                    })
                    self.supabase.table('guilds').insert(guild_data).execute()
                    sync_stats['guilds_synced'] += 1
                    logger.info(f"  ‚úì Created new guild {guild.name}")
                
                # === SYNC MEMBERS ===
                member_batch = []
                for member in guild.members:
                    if member.bot:
                        continue  # Skip bots
                    
                    try:
                        user_id = str(member.id)
                        guild_id = str(guild.id)
                        
                        # Check if user exists
                        user_exists = self.supabase.table('users')\
                            .select('user_id')\
                            .eq('user_id', user_id)\
                            .eq('guild_id', guild_id)\
                            .execute()
                        
                        if user_exists.data:
                            # Update existing user
                            self.supabase.table('users').update({
                                'is_active': True,
                                'updated_at': datetime.utcnow().isoformat()
                            }).eq('user_id', user_id).eq('guild_id', guild_id).execute()
                            sync_stats['members_updated'] += 1
                        else:
                            # Create new user with default balance
                            member_batch.append({
                                'user_id': user_id,
                                'guild_id': guild_id,
                                'balance': 0,
                                'total_earned': 0,
                                'total_spent': 0,
                                'is_active': True,
                                'created_at': datetime.utcnow().isoformat(),
                                'updated_at': datetime.utcnow().isoformat()
                            })
                            sync_stats['members_created'] += 1
                        
                        sync_stats['members_synced'] += 1
                        
                    except Exception as e:
                        logger.error(f"  ‚úó Error syncing member {member.id}: {e}")
                        sync_stats['errors'].append(f"Member {member.id} in {guild.name}: {str(e)}")
                
                # Bulk insert new members
                if member_batch:
                    try:
                        self.supabase.table('users').insert(member_batch).execute()
                        logger.info(f"  ‚úì Created {len(member_batch)} new members")
                    except Exception as e:
                        logger.error(f"  ‚úó Bulk member insert failed: {e}")
                
                # === COUNT CHANNELS AND ROLES ===
                sync_stats['channels_found'] += len(guild.text_channels)
                sync_stats['roles_found'] += len(guild.roles)
                
                # === INITIALIZE TASK SETTINGS IF NOT EXISTS ===
                try:
                    task_settings_check = self.supabase.table('task_settings')\
                        .select('guild_id')\
                        .eq('guild_id', str(guild.id))\
                        .execute()
                    
                    if not task_settings_check.data:
                        self.supabase.table('task_settings').insert({
                            'guild_id': str(guild.id),
                            'allow_user_tasks': True,
                            'max_tasks_per_user': 10,
                            'auto_expire_enabled': True,
                            'require_proof': True,
                            'next_task_id': 1,
                            'total_completed': 0,
                            'total_expired': 0,
                            'created_at': datetime.utcnow().isoformat()
                        }).execute()
                        logger.info(f"  ‚úì Initialized task_settings for {guild.name}")
                except Exception as e:
                    logger.error(f"  ‚úó Error initializing task_settings: {e}")
                
                logger.info(f"  ‚úÖ Completed sync for {guild.name}")
                
            except Exception as e:
                logger.error(f"  ‚ùå Error syncing guild {guild.id}: {e}")
                sync_stats['errors'].append(f"Guild {guild.id}: {str(e)}")
        
        # === MARK INACTIVE GUILDS ===
        await self._mark_inactive_guilds(bot)
        
        sync_stats['end_time'] = datetime.utcnow().isoformat()
        sync_stats['duration_seconds'] = (
            datetime.fromisoformat(sync_stats['end_time'].replace('Z', '+00:00')) -
            datetime.fromisoformat(sync_stats['start_time'].replace('Z', '+00:00'))
        ).total_seconds()
        
        logger.info("=" * 60)
        logger.info("‚úÖ SYNC COMPLETED SUCCESSFULLY")
        logger.info(f"üìä Guilds: {sync_stats['guilds_synced']} new, {sync_stats['guilds_updated']} updated")
        logger.info(f"üë• Members: {sync_stats['members_created']} new, {sync_stats['members_updated']} updated")
        logger.info(f"‚è±Ô∏è  Duration: {sync_stats['duration_seconds']:.2f} seconds")
        if sync_stats['errors']:
            logger.warning(f"‚ö†Ô∏è  Errors: {len(sync_stats['errors'])}")
        logger.info("=" * 60)
        
        return {'success': True, 'stats': sync_stats}
        
    except Exception as e:
        logger.error(f"‚ùå CRITICAL ERROR DURING SYNC: {e}", exc_info=True)
        sync_stats['critical_error'] = str(e)
        sync_stats['end_time'] = datetime.utcnow().isoformat()
        return {'success': False, 'error': str(e), 'stats': sync_stats}

async def _mark_inactive_guilds(self, bot):
    """Mark guilds the bot has left as inactive"""
    try:
        # Get all guilds from database
        db_guilds_response = self.supabase.table('guilds').select('guild_id, server_name').execute()
        db_guild_ids = {g['guild_id']: g['server_name'] for g in db_guilds_response.data}
        
        # Get current bot guilds
        bot_guild_ids = {str(g.id) for g in bot.guilds}
        
        # Find guilds bot left
        left_guild_ids = set(db_guild_ids.keys()) - bot_guild_ids
        
        if left_guild_ids:
            logger.info(f"üö™ Marking {len(left_guild_ids)} guilds as inactive (bot left)")
            for guild_id in left_guild_ids:
                self.supabase.table('guilds').update({
                    'is_active': False,
                    'left_at': datetime.utcnow().isoformat()
                }).eq('guild_id', guild_id).execute()
                logger.info(f"  ‚úì Marked {db_guild_ids[guild_id]} as inactive")
        else:
            logger.info("‚úì No inactive guilds found")
            
    except Exception as e:
        logger.error(f"Error marking inactive guilds: {e}")

Step 2: Add Hourly Sync Background Task
File: bot.py
Add this new background task (place it with other @tasks.loop decorators):
python@tasks.loop(hours=1)
async def hourly_guild_sync():
    """Sync all guild data with Supabase every hour"""
    try:
        logger.info("=" * 60)
        logger.info("‚è∞ HOURLY SYNC TRIGGERED")
        logger.info("=" * 60)
        
        result = await data_manager.sync_all_guilds(bot)
        
        if result.get('success'):
            stats = result.get('stats', {})
            logger.info(f"‚úÖ Hourly sync successful!")
            logger.info(f"   Guilds: {stats.get('guilds_synced', 0)} new + {stats.get('guilds_updated', 0)} updated")
            logger.info(f"   Members: {stats.get('members_created', 0)} new + {stats.get('members_updated', 0)} updated")
            
            if stats.get('errors'):
                logger.warning(f"‚ö†Ô∏è  {len(stats['errors'])} errors occurred during sync")
                for error in stats['errors'][:5]:  # Show first 5 errors
                    logger.warning(f"   - {error}")
        else:
            logger.error(f"‚ùå Hourly sync failed: {result.get('error')}")
            
    except Exception as e:
        logger.error(f"‚ùå Critical error in hourly sync: {e}", exc_info=True)

@hourly_guild_sync.before_loop
async def before_hourly_sync():
    """Wait for bot to be ready before starting hourly sync"""
    await bot.wait_until_ready()
    logger.info("‚úÖ Bot ready - hourly sync task will start in 1 hour")
Update the on_ready event to start hourly sync and run initial sync:
Find the on_ready function and add:
python@bot.event
async def on_ready():
    logger.info(f"Bot logged in as {bot.user.name} (ID: {bot.user.id})")
    logger.info(f"Connected to {len(bot.guilds)} guild(s)")
    
    # ... existing background task starts ...
    
    # Start hourly sync task
    if not hourly_guild_sync.is_running():
        hourly_guild_sync.start()
        logger.info("Hourly guild sync task initialized")
    
    # === RUN INITIAL STARTUP SYNC ===
    logger.info("üöÄ RUNNING INITIAL STARTUP SYNC...")
    try:
        initial_sync_result = await data_manager.sync_all_guilds(bot)
        if initial_sync_result.get('success'):
            logger.info("‚úÖ Initial startup sync completed successfully")
        else:
            logger.error(f"‚ùå Initial sync failed: {initial_sync_result.get('error')}")
    except Exception as e:
        logger.error(f"‚ùå Error during initial sync: {e}", exc_info=True)
    
    logger.info("=" * 50)
    logger.info("ü§ñ BOT IS FULLY READY AND OPERATIONAL")
    logger.info("=" * 50)

Part 3: Full Discord Command Parity with CMS
Create Enhanced Admin Commands Cog
File: Create or update cogs/bot_admin.py
pythonimport discord
from discord import app_commands
from discord.ext import commands
from typing import Optional, Literal
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class BotAdminCommands(commands.Cog):
    """Full CMS feature parity - all dashboard features available via Discord commands"""
    
    def __init__(self, bot):
        self.bot = bot
        self.data_manager = bot.data_manager
    
    # ===== BOT STATUS MANAGEMENT =====
    
    @app_commands.command(name="botstatus", description="Change bot's Discord status and activity")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        status="Bot's online status",
        activity="What the bot is doing",
        text="Activity message text"
    )
    async def bot_status_command(
        self,
        interaction: discord.Interaction,
        status: Literal["online", "idle", "dnd", "invisible"],
        activity: Literal["playing", "watching", "listening", "streaming", "competing"],
        text: str
    ):
        """Change bot status (CMS: Bot Management > Status)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            status_map = {
                "online": discord.Status.online,
                "idle": discord.Status.idle,
                "dnd": discord.Status.dnd,
                "invisible": discord.Status.invisible
            }
            
            activity_map = {
                "playing": discord.ActivityType.playing,
                "watching": discord.ActivityType.watching,
                "listening": discord.ActivityType.listening,
                "streaming": discord.ActivityType.streaming,
                "competing": discord.ActivityType.competing
            }
            
            new_status = status_map[status]
            new_activity = discord.Activity(type=activity_map[activity], name=text)
            
            await self.bot.change_presence(status=new_status, activity=new_activity)
            
            embed = discord.Embed(
                title="‚úÖ Bot Status Updated",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.add_field(name="Status", value=status.title(), inline=True)
            embed.add_field(name="Activity", value=f"{activity.title()} {text}", inline=False)
            embed.set_footer(text=f"Changed by {interaction.user.display_name}")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            logger.info(f"Bot status changed by {interaction.user}: {status} - {activity} {text}")
            
        except Exception as e:
            logger.error(f"Error changing bot status: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ===== SERVER CONFIGURATION =====
    
    @app_commands.command(name="config", description="View current server configuration")
    @app_commands.checks.has_permissions(administrator=True)
    async def view_config(self, interaction: discord.Interaction):
        """View server config (CMS: Settings > View)"""
        await interaction.response.defer()
        
        try:
            guild_id = str(interaction.guild_id)
            config = self.data_manager.supabase.table('guilds').select('*').eq('guild_id', guild_id).execute()
            
            if not config.data:
                await interaction.followup.send("‚ùå Server configuration not found")
                return
            
            cfg = config.data[0]
            
            embed = discord.Embed(
                title=f"‚öôÔ∏è Server Configuration: {interaction.guild.name}",
                color=discord.Color.blue(),
                timestamp=datetime.utcnow()
            )
            
            # Currency settings
            embed.add_field(
                name="üí∞ Currency",
                value=f"Name: `{cfg.get('currency_name', 'coins')}`\nSymbol: `{cfg.get('currency_symbol', '$')}`",
                inline=True
            )
            
            # Features
            features = []
            for feature in ['currency', 'tasks', 'shop', 'announcements', 'moderation']:
                enabled = cfg.get(f'feature_{feature}', False)
                features.append(f"{'‚úÖ' if enabled else '‚ùå'} {feature.title()}")
            
            embed.add_field(name="üéÆ Features", value="\n".join(features), inline=True)
            
            # Channels
            channels_info = []
            if cfg.get('task_channel_id'):
                channels_info.append(f"Tasks: <#{cfg['task_channel_id']}>")
            if cfg.get('shop_channel_id'):
                channels_info.append(f"Shop: <#{cfg['shop_channel_id']}>")
            if cfg.get('log_channel'):
                channels_info.append(f"Logs: <#{cfg['log_channel']}>")
            
            if channels_info:
                embed.add_field(name="üì¢ Special Channels", value="\n".join(channels_info), inline=False)
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}")
    
    @app_commands.command(name="setcurrency", description="Configure server currency")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        name="Currency name (e.g., coins, points, credits)",
        symbol="Currency symbol (e.g., $, ‚≠ê, ü™ô)"
    )
    async def set_currency(self, interaction: discord.Interaction, name: str, symbol: str):
        """Configure currency (CMS: Settings > Currency)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            self.data_manager.supabase.table('guilds').update({
                'currency_name': name,
                'currency_symbol': symbol,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            await interaction.followup.send(
                f"‚úÖ Currency updated!\n**Name:** {name}\n**Symbol:** {symbol}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="setchannel", description="Set special channels")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        channel_type="Type of channel",
        channel="The channel to assign"
    )
    async def set_channel(
        self,
        interaction: discord.Interaction,
        channel_type: Literal["tasks", "shop", "logs", "welcome"],
        channel: discord.TextChannel
    ):
        """Set special channels (CMS: Settings > Channels)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            column_map = {
                "tasks": "task_channel_id",
                "shop": "shop_channel_id",
                "logs": "log_channel",
                "welcome": "welcome_channel"
            }
            
            self.data_manager.supabase.table('guilds').update({
                column_map[channel_type]: str(channel.id),
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            await interaction.followup.send(
                f"‚úÖ {channel_type.title()} channel set to {channel.mention}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="togglefeature", description="Enable/disable bot features")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        feature="Feature to toggle",
        enabled="Enable or disable"
    )
    async def toggle_feature(
        self,
        interaction: discord.Interaction,
        feature: Literal["currency", "tasks", "shop", "announcements", "moderation"],
        enabled: bool
    ):
        """Toggle features (CMS: Settings > Features)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            self.data_manager.supabase.table('guilds').update({
                f'feature_{feature}': enabled,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('guild_id', guild_id).execute()
            
            status = "enabled" if enabled else "disabled"
            await interaction.followup.send(
                f"‚úÖ {feature.title()} feature **{status}**",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ===== USER MANAGEMENT =====
    
    @app_commands.command(name="setbalance", description="Set a user's balance")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        user="User to modify",
        amount="New balance",
        reason="Reason for change"
    )
    async def set_balance(
        self,
        interaction: discord.Interaction,
        user: discord.Member,
        amount: int,
        reason: Optional[str] = "Admin modification"
    ):
        """SetRetryNContinuepython        """Set user balance (CMS: Users > Edit Balance)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            user_id = str(user.id)
            
            # Get current balance
            current = self.data_manager.supabase.table('users')\
                .select('balance')\
                .eq('user_id', user_id)\
                .eq('guild_id', guild_id)\
                .execute()
            
            if not current.data:
                await interaction.followup.send("‚ùå User not found in database", ephemeral=True)
                return
            
            old_balance = current.data[0]['balance']
            difference = amount - old_balance
            
            # Update balance
            self.data_manager.supabase.table('users').update({
                'balance': amount,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('user_id', user_id).eq('guild_id', guild_id).execute()
            
            # Log transaction
            transaction_id = f"txn_{int(datetime.utcnow().timestamp())}_{user_id}"
            self.data_manager.supabase.table('transactions').insert({
                'transaction_id': transaction_id,
                'user_id': user_id,
                'guild_id': guild_id,
                'amount': difference,
                'balance_before': old_balance,
                'balance_after': amount,
                'transaction_type': 'admin_set',
                'description': f"Balance set by {interaction.user.name}: {reason}",
                'timestamp': datetime.utcnow().isoformat()
            }).execute()
            
            embed = discord.Embed(
                title="üí∞ Balance Updated",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.add_field(name="User", value=user.mention, inline=False)
            embed.add_field(name="Old Balance", value=f"{old_balance:,}", inline=True)
            embed.add_field(name="New Balance", value=f"{amount:,}", inline=True)
            embed.add_field(name="Difference", value=f"{difference:+,}", inline=True)
            embed.add_field(name="Reason", value=reason, inline=False)
            embed.set_footer(text=f"Modified by {interaction.user.display_name}")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
        except Exception as e:
            logger.error(f"Error setting balance: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="userstats", description="View detailed user statistics")
    @app_commands.describe(user="User to view")
    async def user_stats(self, interaction: discord.Interaction, user: discord.Member):
        """View user stats (CMS: Users > View Details)"""
        await interaction.response.defer()
        
        try:
            guild_id = str(interaction.guild_id)
            user_id = str(user.id)
            
            # Get user data
            user_data = self.data_manager.supabase.table('users')\
                .select('*')\
                .eq('user_id', user_id)\
                .eq('guild_id', guild_id)\
                .execute()
            
            if not user_data.data:
                await interaction.followup.send("‚ùå User not found")
                return
            
            data = user_data.data[0]
            
            # Get transaction count
            transactions = self.data_manager.supabase.table('transactions')\
                .select('*', count='exact')\
                .eq('user_id', user_id)\
                .eq('guild_id', guild_id)\
                .execute()
            
            # Get inventory count
            inventory = self.data_manager.supabase.table('inventory')\
                .select('*', count='exact')\
                .eq('user_id', user_id)\
                .eq('guild_id', guild_id)\
                .execute()
            
            # Get active tasks
            active_tasks = self.data_manager.supabase.table('user_tasks')\
                .select('*', count='exact')\
                .eq('user_id', user_id)\
                .eq('guild_id', guild_id)\
                .eq('status', 'in_progress')\
                .execute()
            
            embed = discord.Embed(
                title=f"üìä User Statistics",
                description=f"**{user.display_name}** ({user.mention})",
                color=discord.Color.blue(),
                timestamp=datetime.utcnow()
            )
            embed.set_thumbnail(url=user.display_avatar.url)
            
            # Balance info
            embed.add_field(name="üí∞ Current Balance", value=f"{data['balance']:,}", inline=True)
            embed.add_field(name="üìà Total Earned", value=f"{data.get('total_earned', 0):,}", inline=True)
            embed.add_field(name="üìâ Total Spent", value=f"{data.get('total_spent', 0):,}", inline=True)
            
            # Activity info
            embed.add_field(name="üî¢ Transactions", value=f"{transactions.count}", inline=True)
            embed.add_field(name="üéí Inventory Items", value=f"{inventory.count}", inline=True)
            embed.add_field(name="üìã Active Tasks", value=f"{active_tasks.count}", inline=True)
            
            # Timestamps
            created_timestamp = int(datetime.fromisoformat(data['created_at'].replace('Z', '+00:00')).timestamp())
            updated_timestamp = int(datetime.fromisoformat(data['updated_at'].replace('Z', '+00:00')).timestamp())
            
            embed.add_field(name="üìÖ Joined", value=f"<t:{created_timestamp}:R>", inline=True)
            embed.add_field(name="üîÑ Last Active", value=f"<t:{updated_timestamp}:R>", inline=True)
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            logger.error(f"Error getting user stats: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}")
    
    # ===== SHOP MANAGEMENT =====
    
    @app_commands.command(name="shopadd", description="Add item to shop")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        name="Item name",
        price="Item price",
        description="Item description",
        stock="Stock (-1 for unlimited)",
        category="Item category",
        emoji="Item emoji"
    )
    async def shop_add(
        self,
        interaction: discord.Interaction,
        name: str,
        price: int,
        description: str,
        stock: int = -1,
        category: str = "general",
        emoji: Optional[str] = None
    ):
        """Add shop item (CMS: Shop > Add Item)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            item_id = f"item_{int(datetime.utcnow().timestamp())}"
            
            item_data = {
                'item_id': item_id,
                'guild_id': guild_id,
                'name': name,
                'description': description,
                'price': price,
                'stock': stock,
                'category': category,
                'emoji': emoji,
                'is_active': True,
                'metadata': {'sales_count': 0},
                'created_at': datetime.utcnow().isoformat()
            }
            
            self.data_manager.supabase.table('shop_items').insert(item_data).execute()
            
            embed = discord.Embed(
                title="‚úÖ Shop Item Added",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.add_field(name="Name", value=f"{emoji} {name}" if emoji else name, inline=False)
            embed.add_field(name="Price", value=f"{price}", inline=True)
            embed.add_field(name="Stock", value="Unlimited" if stock == -1 else f"{stock}", inline=True)
            embed.add_field(name="Category", value=category, inline=True)
            embed.add_field(name="Description", value=description, inline=False)
            embed.set_footer(text=f"Added by {interaction.user.display_name}")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
        except Exception as e:
            logger.error(f"Error adding shop item: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="shopremove", description="Remove item from shop")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(item_name="Name of item to remove")
    async def shop_remove(self, interaction: discord.Interaction, item_name: str):
        """Remove shop item (CMS: Shop > Delete)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Find item
            item = self.data_manager.supabase.table('shop_items')\
                .select('*')\
                .eq('guild_id', guild_id)\
                .ilike('name', f'%{item_name}%')\
                .execute()
            
            if not item.data:
                await interaction.followup.send(f"‚ùå Item not found: {item_name}", ephemeral=True)
                return
            
            # Delete item
            self.data_manager.supabase.table('shop_items')\
                .delete()\
                .eq('id', item.data[0]['id'])\
                .execute()
            
            await interaction.followup.send(
                f"‚úÖ Removed **{item.data[0]['name']}** from shop",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    @app_commands.command(name="shopupdate", description="Update shop item stock")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        item_name="Item name",
        stock="New stock amount"
    )
    async def shop_update_stock(
        self,
        interaction: discord.Interaction,
        item_name: str,
        stock: int
    ):
        """Update item stock (CMS: Shop > Update Stock)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Find item
            item = self.data_manager.supabase.table('shop_items')\
                .select('*')\
                .eq('guild_id', guild_id)\
                .ilike('name', f'%{item_name}%')\
                .execute()
            
            if not item.data:
                await interaction.followup.send(f"‚ùå Item not found: {item_name}", ephemeral=True)
                return
            
            # Update stock
            self.data_manager.supabase.table('shop_items').update({
                'stock': stock,
                'updated_at': datetime.utcnow().isoformat()
            }).eq('id', item.data[0]['id']).execute()
            
            await interaction.followup.send(
                f"‚úÖ Updated **{item.data[0]['name']}** stock to {stock}",
                ephemeral=True
            )
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ===== ANNOUNCEMENT MANAGEMENT =====
    
    @app_commands.command(name="announce", description="Create server announcement")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(
        channel="Channel to post in",
        title="Announcement title",
        content="Announcement content",
        color="Embed color (hex)",
        pin="Pin the message"
    )
    async def announce(
        self,
        interaction: discord.Interaction,
        channel: discord.TextChannel,
        title: str,
        content: str,
        color: Optional[str] = None,
        pin: bool = False
    ):
        """Create announcement (CMS: Announcements > Create)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            # Parse color
            if color:
                try:
                    color_int = int(color.replace('#', ''), 16)
                    embed_color = discord.Color(color_int)
                except:
                    embed_color = discord.Color.blue()
            else:
                embed_color = discord.Color.blue()
            
            embed = discord.Embed(
                title=title,
                description=content,
                color=embed_color,
                timestamp=datetime.utcnow()
            )
            embed.set_footer(
                text=f"Announced by {interaction.user.display_name}",
                icon_url=interaction.user.display_avatar.url
            )
            
            message = await channel.send(embed=embed)
            
            if pin:
                await message.pin(reason=f"Announcement by {interaction.user.name}")
            
            # Save to database
            announcement_id = f"ann_{int(datetime.utcnow().timestamp())}"
            self.data_manager.supabase.table('announcements').insert({
                'announcement_id': announcement_id,
                'guild_id': str(interaction.guild_id),
                'title': title,
                'content': content,
                'channel_id': str(channel.id),
                'message_id': str(message.id),
                'is_pinned': pin,
                'created_by': str(interaction.user.id),
                'created_at': datetime.utcnow().isoformat()
            }).execute()
            
            await interaction.followup.send(
                f"‚úÖ Announcement posted in {channel.mention}\n"
                f"{'üìå Message pinned' if pin else ''}",
                ephemeral=True
            )
            
        except Exception as e:
            logger.error(f"Error creating announcement: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # ===== SYSTEM MANAGEMENT =====
    
    @app_commands.command(name="syncnow", description="Force sync with Supabase database")
    @app_commands.checks.has_permissions(administrator=True)
    async def sync_now(self, interaction: discord.Interaction):
        """Manual sync (CMS: System > Sync)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            await interaction.followup.send("üîÑ Starting sync...", ephemeral=True)
            
            result = await self.data_manager.sync_all_guilds(self.bot)
            
            if result.get('success'):
                stats = result.get('stats', {})
                
                embed = discord.Embed(
                    title="‚úÖ Sync Completed",
                    color=discord.Color.green(),
                    timestamp=datetime.utcnow()
                )
                embed.add_field(
                    name="Guilds",
                    value=f"New: {stats.get('guilds_synced', 0)}\nUpdated: {stats.get('guilds_updated', 0)}",
                    inline=True
                )
                embed.add_field(
                    name="Members",
                    value=f"New: {stats.get('members_created', 0)}\nUpdated: {stats.get('members_updated', 0)}",
                    inline=True
                )
                embed.add_field(
                    name="Duration",
                    value=f"{stats.get('duration_seconds', 0):.2f}s",
                    inline=True
                )
                
                if stats.get('errors'):
                    embed.add_field(
                        name="‚ö†Ô∏è Errors",
                        value=f"{len(stats['errors'])} errors occurred",
                        inline=False
                    )
                
                await interaction.edit_original_response(content=None, embed=embed)
            else:
                await interaction.edit_original_response(
                    content=f"‚ùå Sync failed: {result.get('error')}"
                )
                
        except Exception as e:
            logger.error(f"Error during manual sync: {e}")
            await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")
    
    @app_commands.command(name="serverstats", description="View comprehensive server statistics")
    @app_commands.checks.has_permissions(administrator=True)
    async def server_stats(self, interaction: discord.Interaction):
        """View server stats (CMS: Overview Dashboard)"""
        await interaction.response.defer()
        
        try:
            guild_id = str(interaction.guild_id)
            
            # Get counts from database
            users_count = self.data_manager.supabase.table('users')\
                .select('*', count='exact')\
                .eq('guild_id', guild_id)\
                .execute()
            
            tasks_count = self.data_manager.supabase.table('tasks')\
                .select('*', count='exact')\
                .eq('guild_id', guild_id)\
                .execute()
            
            shop_items_count = self.data_manager.supabase.table('shop_items')\
                .select('*', count='exact')\
                .eq('guild_id', guild_id)\
                .execute()
            
            transactions_count = self.data_manager.supabase.table('transactions')\
                .select('*', count='exact')\
                .eq('guild_id', guild_id)\
                .execute()
            
            # Calculate total economy value
            users_data = self.data_manager.supabase.table('users')\
                .select('balance')\
                .eq('guild_id', guild_id)\
                .execute()
            
            total_balance = sum(u.get('balance', 0) for u in users_data.data) if users_data.data else 0
            
            embed = discord.Embed(
                title=f"üìä Server Statistics",
                description=f"**{interaction.guild.name}**",
                color=discord.Color.gold(),
                timestamp=datetime.utcnow()
            )
            
            if interaction.guild.icon:
                embed.set_thumbnail(url=interaction.guild.icon.url)
            
            # Economy stats
            embed.add_field(
                name="üí∞ Economy",
                value=f"Total in circulation: **{total_balance:,}**\nTransactions: **{transactions_count.count}**",
                inline=False
            )
            
            # User stats
            embed.add_field(
                name="üë• Users",
                value=f"Registered: **{users_count.count}**\nDiscord members: **{interaction.guild.member_count}**",
                inline=True
            )
            
            # Content stats
            embed.add_field(
                name="üìã Content",
                value=f"Tasks: **{tasks_count.count}**\nShop items: **{shop_items_count.count}**",
                inline=True
            )
            
            # Server info
            embed.add_field(
                name="üè∞ Server",
                value=f"Channels: **{len(interaction.guild.text_channels)}**\nRoles: **{len(interaction.guild.roles)}**",
                inline=True
            )
            
            embed.set_footer(text=f"Requested by {interaction.user.display_name}")
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            logger.error(f"Error getting server stats: {e}")
            await interaction.followup.send(f"‚ùå Error: {str(e)}")
    
    @app_commands.command(name="listinactive", description="List inactive users")
    @app_commands.checks.has_permissions(administrator=True)
    @app_commands.describe(days="Days of inactivity")
    async def list_inactive(self, interaction: discord.Interaction, days: int = 30):
        """List inactive users (CMS: Users > Inactive)"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            guild_id = str(interaction.guild_id)
            cutoff_date = (datetime.utcnow() - timedelta(days=days)).isoformat()
            
            inactive_users = self.data_manager.supabase.table('users')\
                .select('user_id, balance, updated_at')\
                .eq('guild_id', guild_id)\
                .lt('updated_at', cutoff_date)\
                .execute()
            
            if not inactive_users.data:
                await interaction.followup.send(
                    f"‚úÖ No users inactive for {days}+ days",
                    ephemeral=True
                )
                return
            
            # Format list
            inactive_list = []
            for user in inactive_users.data[:10]:  # Limit to 10
                try:
                    member = await interaction.guild.fetch_member(int(user['user_id']))
                    inactive_list.append(
                        f"‚Ä¢ {member.mention} - Balance: {user['balance']:,} - "
                        f"Last active: <t:{int(datetime.fromisoformat(user['updated_at'].replace('Z', '+00:00')).timestamp())}:R>"
                    )
                except:
                    inactive_list.append(f"‚Ä¢ User ID {user['user_id']} - Balance: {user['balance']:,}")
            
            embed = discord.Embed(
                title=f"üò¥ Inactive Users ({days}+ days)",
                description="\n".join(inactive_list),
                color=discord.Color.orange(),
                timestamp=datetime.utcnow()
            )
            
            if len(inactive_users.data) > 10:
                embed.set_footer(text=f"Showing 10 of {len(inactive_users.data)} inactive users")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
        except Exception as e:
            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)

async def setup(bot):
    await bot.add_cog(BotAdminCommands(bot))

Part 4: Load New Admin Cog
File: bot.py
Find where cogs are loaded and add:
python# In the cog loading section
try:
    await bot.load_extension('cogs.bot_admin')
    logger.info("‚úì Bot Admin cog loaded")
except Exception as e:
    logger.error(f"‚úó Failed to load bot_admin cog: {e}")

Complete Implementation Checklist
Phase 1: Bug Fixes (Deploy First)

 backend.py line 3575: Change time.sleep(self.BATCH_INTERVAL) to time_module.sleep(self.BATCH_INTERVAL)
 backend.py line 3585: Change time.sleep(self.KEEPALIVE_INTERVAL) to time_module.sleep(self.KEEPALIVE_INTERVAL)
 cogs/tasks.py: Add from core.task_manager import TaskManager (or create TaskManager class)
 core/data_manager.py: Add get_cache_stats(), _calculate_hit_rate(), and clear_expired_cache() methods
 bot.py: Update cache_cleanup_job to handle methods gracefully

Phase 2: Sync System (Deploy Second)

 core/data_manager.py: Add sync_all_guilds() method
 core/data_manager.py: Add _mark_inactive_guilds() method
 bot.py: Add hourly_guild_sync background task
 bot.py: Update on_ready to run initial sync and start hourly task

Phase 3: Discord Commands (Deploy Third)

 Create cogs/bot_admin.py with all admin commands
 bot.py: Load bot_admin cog
 Test all commands in Discord


Deployment Strategy
bash# Phase 1: Critical bug fixes
git add backend.py cogs/tasks.py core/data_manager.py bot.py
git commit -m "Fix: SSE time errors, TaskManager import, cache methods"
git push origin main

# Wait for deployment, verify bot starts cleanly

# Phase 2: Add sync system
git add core/data_manager.py bot.py
git commit -m "Feature: Hourly Supabase sync with startup sync"
git push origin main

# Wait for deployment, verify sync runs

# Phase 3: Add Discord commands
git add cogs/bot_admin.py bot.py
git commit -m "Feature: Full Discord command parity with CMS dashboard"
git push origin main

Verification Tests
After Phase 1:
bash# Check Railway logs
railway logs --tail 50

# Should see:
‚úÖ No "NameError: name 'time' is not defined"
‚úÖ Tasks cog loads successfully
‚úÖ Cache cleanup runs without errors
After Phase 2:
bash# Check for sync messages in logs:
‚úÖ "STARTING COMPREHENSIVE GUILD SYNC"
‚úÖ "Synced X guilds, Y members"
‚úÖ "Hourly sync task initialized"
After Phase 3:
bash# Test Discord commands:
/botstatus online playing Testing
/config
/setbalance @user 1000 Testing
/shopadd TestItem 100 "Test item"
/announce #general "Test" "This is a test"
/syncnow
/serverstats

Success Criteria
‚úÖ No runtime errors in Railway logs
‚úÖ Tasks cog loads successfully
‚úÖ Cache cleanup runs every hour without errors
‚úÖ Initial sync runs on bot startup
‚úÖ Hourly sync runs automatically
‚úÖ All Discord commands work and match CMS functionality
‚úÖ Data stays in sync between Discord and Supabase
This implementation gives you a fully functional bot with automated syncing and complete command parity!
